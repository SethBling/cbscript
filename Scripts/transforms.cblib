import common
import math

$InverseMass = 500
$InverseRotationalIntertia = 500
$Precision = 1000
$Half = 500
$CancelRestitution = -100
$Billion = 1000000000

$CollisionCubePointWorldFace = 1
$CollisionCubeFaceWorldPoint = 2
$CollisionCubeEdgeWorldEdge = 3
$CollisionCubeFaceCubePoint = 4
$CollisionCubeEdgeCubeEdge = 5



define @PhysicsBlock = @Entity[type=block_display,tag=physics_block]

end

function initialize_transforms()
    initialize_vertex_adjacency()
    
    Gravity = 45
    Restitution = 600
    collision_frame = 0
end


# These lines register the variables for the matrix_multiply functions
# It doesn't actually need to be called.
function register_transform_variables()
    accum = 0
    m_00 = 0
    m_01 = 0
    m_02 = 0
    m_10 = 0
    m_11 = 0
    m_12 = 0
    m_20 = 0
    m_21 = 0
    m_22 = 0
end

function quaternion_multiply(w1, i1, j1, k1, w2, i2, j2, k2)
    new_w = (w1*w2 - i1*i2 - j1*j2 - k1*k2) / $Precision
    new_i = (w1*i2 + i1*w2 + j1*k2 - k1*j2) / $Precision
    new_j = (w1*j2 - i1*k2 + j1*w2 + k1*i2) / $Precision
    new_k = (w1*k2 + i1*j2 - j1*i2 + k1*w2) / $Precision
end

# Assumes $namespace:global args contains
# $(m1) $(m2) and $(out), which contain the names of matrices, where a matrix
# has indexed values like m_00, m_01
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:matrix_multiply with storage $namespace:global args
function matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score $(out)_$row$col run scoreboard players get $(m1)_$row0
            /$scoreboard players operation $(out)_$row$col *= $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get $(m1)_$row1
            /$scoreboard players operation Global accum *= $(m2)_1$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get $(m1)_$row2
            /$scoreboard players operation Global accum *= $(m2)_2$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$scoreboard players operation $(out)_$row$col /= c1000 Constant
        end
    end
end

# Transposes m1 before multiplying by m2
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:transpose_matrix_multiply with storage $namespace:global args
function transpose_matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score $(out)_$row$col run scoreboard players get $(m1)_0$row
            /$scoreboard players operation $(out)_$row$col *= $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get $(m1)_1$row
            /$scoreboard players operation Global accum *= $(m2)_1$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get $(m1)_2$row
            /$scoreboard players operation Global accum *= $(m2)_2$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$scoreboard players operation $(out)_$row$col /= c1000 Constant
        end
    end
end

# Source for the math: https://math.stackexchange.com/questions/2213165/find-shortest-distance-between-lines-in-3d
function get_closest_points_on_edges(o1x, o1y, o1z, d1x, d1y, d1z, o2x, o2y, o2z, d2x, d2y, d2z)
    # Cross the two directions to get the normal
    nx = (d1y * d2z - d1z * d2y) / $Precision
    ny = (d1z * d2x - d1x * d2z) / $Precision
    nz = (d1x * d2y - d1y * d2x) / $Precision

    # Get the square magnitude of the normal, scaled up by the Precision
    nmagsq = (nx*nx + ny*ny + nz*nz) / $Precision
    
    # Difference of origins
    odx = o2x - o1x
    ody = o2y - o1y
    odz = o2z - o1z
    
    # Get a vector perpendicular to the normal and the second ray
    perpx = (d2y * nz - d2z * ny) / $Precision
    perpy = (d2z * nx - d2x * nz) / $Precision
    perpz = (d2x * ny - d2y * nx) / $Precision
    
    # Get the projected distance along the first ray
    t1 = (perpx * odx + perpy * ody + perpz * odz) / nmagsq

    # Get the point on the first ray
    p1x = o1x + t1 * d1x / $Precision
    p1y = o1y + t1 * d1y / $Precision
    p1z = o1z + t1 * d1z / $Precision

    # Get a vector perpendicular to the normal and the first ray
    perpx = (d1y * nz - d1z * ny) / $Precision
    perpy = (d1z * nx - d1x * nz) / $Precision
    perpz = (d1x * ny - d1y * nx) / $Precision
    
    # Get the projected distance along the second ray
    t2 = (perpx * odx + perpy * ody + perpz * odz) / nmagsq
    
    # Get the point on the second ray
    p2x = o2x + t2 * d2x / $Precision
    p2y = o2y + t2 * d2y / $Precision
    p2z = o2z + t2 * d2z / $Precision
end

function create_collider(x, y, z, size, inv_mass, inv_rot_int)
    define name collider = "collider_$(collider)"
    
    /scoreboard players set collider_$(collider) id $(collider)
    
    collider.x = x
    collider.y = y
    collider.z = z
    collider.size = size
    collider.halfsize = size / 2
    collider.inv_mass = inv_mass
    collider.inv_rot_int = inv_rot_int
    
    collider.w = $Precision
    collider.i = 0
    collider.j = 0
    collider.k = 0
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider_wake_up() with macros
    
    collider_quaternion_to_transform() with macros

    /$summon minecraft:block_display ~ ~ ~ {block_state:{Name:"minecraft:$(block_name)",Count:0b}, interpolation_duration: 1, teleport_duration: 1, Tags:["physics_block"]}
    @PhysicsBlock.age++
    as @PhysicsBlock[age == 1]
        /scoreboard players set @s collider_id $(collider)
        @s.<pos> = <x, y, z>
    end
end

function collider_clear_velocity()
    define name collider = "collider_$(collider)"

    collider.velocity_x = 0
    collider.velocity_y = 0
    collider.velocity_z = 0
end

function collider_clear_rotation()
    define name collider = "collider_$(collider)"

    collider.rotation_x = 0
    collider.rotation_y = 0
    collider.rotation_z = 0
end

function collider_wake_up()
    define name collider = "collider_$(collider)"

    collider.recent_motion = 10000
    collider.recent_rotation = 10000
    collider.sleeping = False
end

function collider_sleep()
    define name collider = "collider_$(collider)"
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider.sleeping = True
end

function collider_check_sleep()
    define name collider = "collider_$(collider)"
    
    if collider.recent_motion < 2500 and collider.recent_rotation < 2500
        collider_sleep() with macros
    end
end

function collider_integrate()
    define name collider = "collider_$(collider)"
    
    collider_integrate_velocity() with macros
    collider_integrate_rotation() with macros
end

function collider_integrate_velocity()
    define name collider = "collider_$(collider)"
    
    collider.velocity_x = (collider.velocity_x * 995 + $Half) / $Precision
    collider.velocity_y = (collider.velocity_y * 995 + $Half) / $Precision
    collider.velocity_z = (collider.velocity_z * 995 + $Half) / $Precision
    
    collider.x += collider.velocity_x
    collider.y += collider.velocity_y
    collider.z += collider.velocity_z
    
    if DebugCollisions
        tell @a "#(collider.id) velocity update (collider.velocity_x), (collider.velocity_y), (collider.velocity_z)"
    end
    
    motion = (collider.velocity_x * collider.velocity_x + collider.velocity_y * collider.velocity_y + collider.velocity_z * collider.velocity_z) / 10
    collider.recent_motion *= 9
    collider.recent_motion /= 10
    collider.recent_motion += motion
end

function collider_integrate_rotation()
    define name collider = "collider_$(collider)"
    
    collider.rotation_x = (collider.rotation_x * 995 + $Half) / $Precision
    collider.rotation_y = (collider.rotation_y * 995 + $Half) / $Precision
    collider.rotation_z = (collider.rotation_z * 995 + $Half) / $Precision
    
    quaternion_multiply(0, collider.rotation_x, collider.rotation_y, collider.rotation_z, collider.w, collider.i, collider.j, collider.k)
    
    collider.w += new_w / 2
    collider.i += new_i / 2
    collider.j += new_j / 2
    collider.k += new_k / 2

    collider_normalize_quaternion() with macros

    rotation = (collider.rotation_x * collider.rotation_x + collider.rotation_y * collider.rotation_y + collider.rotation_z * collider.rotation_z) / 10
    collider.recent_rotation *= 9
    collider.recent_rotation /= 10
    collider.recent_rotation += motion
end

function collider_set_transform()
    define name collider = "collider_$(collider)"

    /data modify storage $namespace:global transformation set value [1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f]
    d00 = collider.t00 * collider.size / $Precision
    d01 = collider.t01 * collider.size / $Precision
    d02 = collider.t02 * collider.size / $Precision
    d10 = collider.t10 * collider.size / $Precision
    d11 = collider.t11 * collider.size / $Precision
    d12 = collider.t12 * collider.size / $Precision
    d20 = collider.t20 * collider.size / $Precision
    d21 = collider.t21 * collider.size / $Precision
    d22 = collider.t22 * collider.size / $Precision
    dx = (d00 + d01 + d02) / -2
    dy = (d10 + d11 + d12) / -2
    dz = (d20 + d21 + d22) / -2
    
    for $pair in [[0,"d00"], [1,"d01"], [2,"d02"], [3,"dx"], [4,"d10"], [5,"d11"], [6,"d12"], [7,"dy"], [8,"d20"], [9,"d21"], [10,"d22"], [11,"dz"]]
        $idx = $pair[0]
        $var = $pair[1]
        $downscale = 1.0 / $Precision
        /execute store result storage $namespace:global transformation[$idx] float $downscale run scoreboard players get Global $var
    end
    
    as @PhysicsBlock
        if @s.collider_id == collider.id
            @s.x = collider.x
            @s.y = collider.y
            @s.z = collider.z
            /data modify entity @s transformation set from storage transform_test:global transformation
            /data modify entity @s start_interpolation set value 0b
        end
    end
end

function collider_normalize_quaternion()
    define name collider = "collider_$(collider)"

    mag = sqrt(collider.w*collider.w + collider.i*collider.i + collider.j*collider.j + collider.k*collider.k)
    
    collider.w *= $Precision
    collider.w += $Half
    collider.w /= mag
    collider.i *= $Precision
    collider.i += $Half
    collider.i /= mag
    collider.j *= $Precision
    collider.j += $Half
    collider.j /= mag
    collider.k *= $Precision
    collider.k += $Half
    collider.k /= mag
end

function collider_multiply_quaternion_right(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(collider.w, collider.i, collider.j, collider.k, w, i, j, k)
    
    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_multiply_quaternion_left(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(w, i, j, k, collider.w, collider.i, collider.j, collider.k)

    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_quaternion_to_transform()
    define name collider = "collider_$(collider)"

    collider.t00 = $Precision - (2 * collider.j * collider.j) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t01 = (2 * collider.i * collider.j) / $Precision - (2 * collider.k * collider.w) / $Precision
    collider.t02 = (2 * collider.i * collider.k) / $Precision + (2 * collider.j * collider.w) / $Precision

    collider.t10 = (2 * collider.i * collider.j) / $Precision + (2 * collider.k * collider.w) / $Precision
    collider.t11 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t12 = (2 * collider.j * collider.k) / $Precision - (2 * collider.i * collider.w) / $Precision

    collider.t20 = (2 * collider.i * collider.k) / $Precision - (2 * collider.j * collider.w) / $Precision
    collider.t21 = (2 * collider.j * collider.k) / $Precision + (2 * collider.i * collider.w) / $Precision
    collider.t22 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.j * collider.j) / $Precision
end

function collider_local_to_world(x, y, z, translation)
    define name collider = "collider_$(collider)"

    world_x = (collider.t00 * x + collider.t01 * y + collider.t02 * z) / $Precision
    world_y = (collider.t10 * x + collider.t11 * y + collider.t12 * z) / $Precision
    world_z = (collider.t20 * x + collider.t21 * y + collider.t22 * z) / $Precision
    
    if translation
        world_x += collider.x
        world_y += collider.y
        world_z += collider.z
    end
end

function collider_world_to_local(x, y, z, translation)
    define name collider = "collider_$(collider)"

    if translation
        x -= collider.x
        y -= collider.y
        z -= collider.z
    end
    
    local_x = (collider.t00 * x + collider.t10 * y + collider.t20 * z) / $Precision
    local_y = (collider.t01 * x + collider.t11 * y + collider.t21 * z) / $Precision
    local_z = (collider.t02 * x + collider.t12 * y + collider.t22 * z) / $Precision
end

function collider_apply_impulse(x, y, z, ix, iy, iz)
    define name collider = "collider_$(collider)"
    
    collider.velocity_x += (ix * collider.inv_mass + $Half) / $Precision
    collider.velocity_y += (iy * collider.inv_mass + $Half) / $Precision
    collider.velocity_z += (iz * collider.inv_mass + $Half) / $Precision

    dx = x - collider.x
    dy = y - collider.y
    dz = z - collider.z
    
    axis_x = (dy * iz - dz * iy + $Half) / $Precision
    axis_y = (dz * ix - dx * iz + $Half) / $Precision
    axis_z = (dx * iy - dy * ix + $Half) / $Precision
    
    collider.rotation_x += (axis_x * collider.inv_rot_int) / $Precision
    collider.rotation_y += (axis_y * collider.inv_rot_int) / $Precision
    collider.rotation_z += (axis_z * collider.inv_rot_int) / $Precision
    
    if collider.sleeping
        collider_wake_up() with macros
    end
end

function collider_apply_spring_cable(spring_x, spring_y, spring_z, spring_neutral, spring_constant, local_att_x, local_att_y, local_att_z)
    define name collider = "collider_$(collider)"

    collider_local_to_world(local_att_x, local_att_y, local_att_z, True) with macros
    
    spring_dx = world_x - spring_x
    spring_dy = world_y - spring_y
    spring_dz = world_z - spring_z
    
    # Current length of the spring
    spring_mag = sqrt(spring_dx*spring_dx + spring_dy*spring_dy + spring_dz*spring_dz)
    
    # Spring displacement from neutral
    spring_disp = spring_mag - spring_neutral
    
    spring_dir_x = spring_dx * $Precision / spring_mag
    spring_dir_y = spring_dy * $Precision / spring_mag
    spring_dir_z = spring_dz * $Precision / spring_mag
    
    if spring_mag > spring_neutral
        force_x = -spring_dir_x * spring_disp / $Precision * spring_constant / $Precision
        force_y = -spring_dir_y * spring_disp / $Precision * spring_constant / $Precision
        force_z = -spring_dir_z * spring_disp / $Precision * spring_constant / $Precision
        
        collider_apply_impulse(world_x, world_y, world_z, force_x, force_y, force_z) with macros
    end
end

function collider_ray_intersection(x, y, z, dx, dy, dz)
    define name collider = "collider_$(collider)"

    collider_world_to_local(x, y, z, True) with macros
    local_origin_x = local_x
    local_origin_y = local_y
    local_origin_z = local_z
    
    collider_world_to_local(dx, dy, dz, False) with macros
    local_dx = local_x
    local_dy = local_y
    local_dz = local_z
    
    if local_dx == 0
        local_dx = 1
    end
    if local_dy == 0
        local_dy = 1
    end
    if local_dz == 0
        local_dz = 1
    end
    
    halfsize = collider.size / 2
    
    # Calculate the times of entry/exit along each axis
    txn = (-halfsize - local_origin_x) * $Precision / local_dx
    txp = (halfsize - local_origin_x) * $Precision / local_dx
    tyn = (-halfsize - local_origin_y) * $Precision / local_dy
    typ = (halfsize - local_origin_y) * $Precision / local_dy
    tzn = (-halfsize - local_origin_z) * $Precision / local_dz
    tzp = (halfsize - local_origin_z) * $Precision / local_dz
    
    # Figure out the minimum and maximum time along the x axis
    if txn > txp
        min_tx = txp
        max_tx = txn
        x_normal = $Precision
    else
        min_tx = txn
        max_tx = txp
        x_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the y axis
    if tyn > typ
        min_ty = typ
        max_ty = tyn
        y_normal = $Precision
    else
        min_ty = tyn
        max_ty = typ
        y_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the z axis
    if tzn > tzp
        min_tz = tzp
        max_tz = tzn
        z_normal = $Precision
    else
        min_tz = tzn
        max_tz = tzp
        z_normal = -$Precision
    end
    
    # Figure out which axis we enter the cube last. Once the ray
    # has entered the cube along all 3 axes, it can collide.
    if min_tx > min_ty and min_tx > min_tz
        min_t = min_tx
        local_cnx = x_normal
        local_cny = 0
        local_cnz = 0
    else if min_ty > min_tz
        min_t = min_ty
        local_cnx = 0
        local_cny = y_normal
        local_cnz = 0
    else
        min_t = min_tz
        local_cnx = 0
        local_cny = 0
        local_cnz = z_normal
    end

    # Figure out which axis we exited the cube first. Once the ray
    # has exited the cube along any axis, it's no longer colliding.
    if max_tx < max_ty and max_tx < max_tz
        max_t = max_tx
    else if max_ty < max_tz
        max_t = max_ty
    else
        max_t = max_tz
    end
    
    # If the ray entered the cube along all three axes before it
    # exited along any axis, and it exited in front of us and not
    # behind us, then the ray intersections the cube, first hitting
    # it at t=min_t.
    if min_t < max_t and max_t > 0
        t = min_t
        
        if t < 0
            t = 0
        end
        
        local_cx = local_origin_x + t * local_dx / $Precision
        local_cy = local_origin_y + t * local_dy / $Precision
        local_cz = local_origin_z + t * local_dz / $Precision
        
        collider_local_to_world(local_cx, local_cy, local_cz, True) with macros
        collision_x = world_x
        collision_y = world_y
        collision_z = world_z
        
        collider_local_to_world(local_cnx, local_cny, local_cnz, False) with macros
        collision_nx = world_x
        collision_ny = world_y
        collision_nz = world_z
        
        return True
    else
        return False
    end
end

function initialize_vertex_adjacency()
    vertex_0_adj_1.val = 2
    vertex_0_adj_2.val = 4
    vertex_0_adj_3.val = 7

    vertex_1_adj_1.val = 3
    vertex_1_adj_2.val = 5
    vertex_1_adj_3.val = 6

    vertex_2_adj_1.val = 0
    vertex_2_adj_2.val = 5
    vertex_2_adj_3.val = 6

    vertex_3_adj_1.val = 1
    vertex_3_adj_2.val = 4
    vertex_3_adj_3.val = 7

    vertex_4_adj_1.val = 0
    vertex_4_adj_2.val = 3
    vertex_4_adj_3.val = 6

    vertex_5_adj_1.val = 1
    vertex_5_adj_2.val = 2
    vertex_5_adj_3.val = 7

    vertex_6_adj_1.val = 1
    vertex_6_adj_2.val = 2
    vertex_6_adj_3.val = 4

    vertex_7_adj_1.val = 0
    vertex_7_adj_2.val = 3
    vertex_7_adj_3.val = 5
end

function collider_calculate_vertex_world_positions()
    define name collider = "collider_$(collider)"
    
    halfsize = collider.size / 2
    
    # Initialized AABB
    collider.min_x = collider.x
    collider.min_y = collider.y
    collider.min_z = collider.z
    collider.max_x = collider.x
    collider.max_y = collider.y
    collider.max_z = collider.z

    define name axis = "collider_$(collider)_a$(axis)"
    define name v0 = "collider_$(collider)_v0"
    define name v1 = "collider_$(collider)_v1"
    define name v2 = "collider_$(collider)_v2"
    define name v3 = "collider_$(collider)_v3"
    define name v4 = "collider_$(collider)_v4"
    define name v5 = "collider_$(collider)_v5"
    define name v6 = "collider_$(collider)_v6"
    define name v7 = "collider_$(collider)_v7"
    
    v0.x = collider.x
    v0.y = collider.y
    v0.z = collider.z
    
    v1.x = collider.x
    v1.y = collider.y
    v1.z = collider.z
    
    v2.x = collider.x
    v2.y = collider.y
    v2.z = collider.z
    
    v3.x = collider.x
    v3.y = collider.y
    v3.z = collider.z
    
    v4.x = collider.x
    v4.y = collider.y
    v4.z = collider.z
    
    v5.x = collider.x
    v5.y = collider.y
    v5.z = collider.z
    
    v6.x = collider.x
    v6.y = collider.y
    v6.z = collider.z
    
    v7.x = collider.x
    v7.y = collider.y
    v7.z = collider.z
    
    collider_local_to_world($Precision, 0, 0, False) with macros

    define name axis = "collider_$(collider)_a0"

    axis.x = world_x
    axis.y = world_y
    axis.z = world_z
    
    world_x *= collider.halfsize
    world_x /= $Precision
    world_y *= collider.halfsize
    world_y /= $Precision
    world_z *= collider.halfsize
    world_z /= $Precision
    
    v0.x += world_x
    v0.y += world_y
    v0.z += world_z
    
    v1.x -= world_x
    v1.y -= world_y
    v1.z -= world_z
    
    v2.x += world_x
    v2.y += world_y
    v2.z += world_z
    
    v3.x -= world_x
    v3.y -= world_y
    v3.z -= world_z

    v4.x += world_x
    v4.y += world_y
    v4.z += world_z
    
    v5.x -= world_x
    v5.y -= world_y
    v5.z -= world_z
    
    v6.x += world_x
    v6.y += world_y
    v6.z += world_z
    
    v7.x -= world_x
    v7.y -= world_y
    v7.z -= world_z
    
    collider_local_to_world(0, $Precision, 0, False) with macros

    define name axis = "collider_$(collider)_a1"
    axis.x = world_x
    axis.y = world_y
    axis.z = world_z
    
    world_x *= collider.halfsize
    world_x /= $Precision
    world_y *= collider.halfsize
    world_y /= $Precision
    world_z *= collider.halfsize
    world_z /= $Precision
    
    v0.x += world_x
    v0.y += world_y
    v0.z += world_z
    
    v1.x -= world_x
    v1.y -= world_y
    v1.z -= world_z
    
    v2.x -= world_x
    v2.y -= world_y
    v2.z -= world_z
    
    v3.x += world_x
    v3.y += world_y
    v3.z += world_z

    v4.x += world_x
    v4.y += world_y
    v4.z += world_z
    
    v5.x -= world_x
    v5.y -= world_y
    v5.z -= world_z
    
    v6.x -= world_x
    v6.y -= world_y
    v6.z -= world_z
    
    v7.x += world_x
    v7.y += world_y
    v7.z += world_z
    
    collider_local_to_world(0, 0, $Precision, False) with macros

    define name axis = "collider_$(collider)_a2"
    axis.x = world_x
    axis.y = world_y
    axis.z = world_z
        
    world_x *= collider.halfsize
    world_x /= $Precision
    world_y *= collider.halfsize
    world_y /= $Precision
    world_z *= collider.halfsize
    world_z /= $Precision
    
    v0.x += world_x
    v0.y += world_y
    v0.z += world_z
    
    v1.x -= world_x
    v1.y -= world_y
    v1.z -= world_z
    
    v2.x += world_x
    v2.y += world_y
    v2.z += world_z
    
    v3.x -= world_x
    v3.y -= world_y
    v3.z -= world_z

    v4.x -= world_x
    v4.y -= world_y
    v4.z -= world_z
    
    v5.x += world_x
    v5.y += world_y
    v5.z += world_z
    
    v6.x -= world_x
    v6.y -= world_y
    v6.z -= world_z
    
    v7.x += world_x
    v7.y += world_y
    v7.z += world_z
    
    for vertex = 0 to 7
        with
            $(vertex) = vertex
        do
            define name vertex = "collider_$(collider)_v$(vertex)"
            if vertex.x < collider.min_x
                collider.min_x = vertex.x
            end
            if vertex.x > collider.max_x
                collider.max_x = vertex.x
            end
            if vertex.y < collider.min_y
                collider.min_y = vertex.y
            end
            if vertex.y > collider.max_y
                collider.max_y = vertex.y
            end
            if vertex.z < collider.min_z
                collider.min_z = vertex.z
            end
            if vertex.z > collider.max_z
                collider.max_z = vertex.z
            end
        end
    end
end

function get_collider_world_collisions()
    define name collider = "collider_$(collider)"
    define name collider_a0 = "collider_$(collider)_a0"
    define name collider_a1 = "collider_$(collider)_a1"
    define name collider_a2 = "collider_$(collider)_a2"
    
    # Initialize block axes
    
    # 1,0,0
    separating_axis_3.x = $Precision
    separating_axis_3.y = 0
    separating_axis_3.z = 0
    
    hs_x = collider_a0.x
    if hs_x < 0
        hs_x *= -1
    end
    hs_y = collider_a1.x
    if hs_y < 0
        hs_y *= -1
    end
    hs_z = collider_a2.x
    if hs_z < 0
        hs_z *= -1
    end
    
    separating_axis_3.halfsize = (hs_x + hs_y + hs_z) * collider.halfsize / $Precision + $Half

    # 0,1,0
    separating_axis_4.x = 0
    separating_axis_4.y = $Precision
    separating_axis_4.z = 0
    
    hs_x = collider_a0.y
    if hs_x < 0
        hs_x *= -1
    end
    hs_y = collider_a1.y
    if hs_y < 0
        hs_y *= -1
    end
    hs_z = collider_a2.y
    if hs_z < 0
        hs_z *= -1
    end
    
    separating_axis_4.halfsize = (hs_x + hs_y + hs_z) * collider.halfsize / $Precision + $Half
    
    # 0,0,1
    separating_axis_5.x = 0
    separating_axis_5.y = 0
    separating_axis_5.z = $Precision
    
    hs_x = collider_a0.z
    if hs_x < 0
        hs_x *= -1
    end
    hs_y = collider_a1.z
    if hs_y < 0
        hs_y *= -1
    end
    hs_z = collider_a2.z
    if hs_z < 0
        hs_z *= -1
    end
    
    separating_axis_5.halfsize = (hs_x + hs_y + hs_z) * collider.halfsize / $Precision + $Half
    
    # Initialize the cube face and edge-edge separating axes
    edge_axis = 6
    
    for axis = 0 to 2
        with
            $(axis) = axis
        do
            define name collider_axis = "collider_$(collider)_a$(axis)"
            define name separating_axis = "separating_axis_$(axis)"
            
            separating_axis.x = collider_axis.x
            separating_axis.y = collider_axis.y
            separating_axis.z = collider_axis.z
            
            hs_x = separating_axis.x
            if hs_x < 0
                hs_x *= -1
            end
            hs_y = separating_axis.y
            if hs_y < 0
                hs_y *= -1
            end
            hs_z = separating_axis.z
            if hs_z < 0
                hs_z *= -1
            end
            
            separating_axis.halfsize = collider.halfsize + (hs_x + hs_y + hs_z) / 2
            
            with
                $(edge_0) = edge_axis
                $(edge_1) = edge_axis+1
                $(edge_2) = edge_axis+2
            do
                define name edge0 = "separating_axis_$(edge_0)"
                define name edge1 = "separating_axis_$(edge_1)"
                define name edge2 = "separating_axis_$(edge_2)"
                
                
                # Cross with 1,0,0
                mag = sqrt(collider_axis.y*collider_axis.y + collider_axis.z*collider_axis.z)
                edge0.x = 0
                edge0.y = collider_axis.z * $Precision / mag
                edge0.z = -collider_axis.y * $Precision / mag

                # Cross with 0,1,0
                mag = sqrt(collider_axis.x*collider_axis.x + collider_axis.z*collider_axis.z)
                edge1.x = -collider_axis.z * $Precision / mag
                edge1.y = 0
                edge1.z = collider_axis.x * $Precision / mag

                # Cross with 0,0,1
                mag = sqrt(collider_axis.x*collider_axis.x + collider_axis.y*collider_axis.y)
                edge2.x = collider_axis.y * $Precision / mag
                edge2.y = -collider_axis.x * $Precision / mag
                edge2.z = 0
                
                for edge_iter = 0 to 2
                    with
                        $(edge_axis) = edge_axis
                    do
                        define name edge = "separating_axis_$(edge_axis)"
                        
                        edge.halfsize = 0
                        
                        for cube_axis = 0 to 2
                            with
                                $(cube_axis) = cube_axis
                            do
                                define name cube_axis = "collider_$(collider)_a$(cube_axis)"
                                # Cube Halfsize
                                unless axis == cube_axis                                
                                    cube_hs = cube_axis.x * edge.x
                                    cube_hs += cube_axis.y * edge.y
                                    cube_hs += cube_axis.z * edge.z
                                    
                                    cube_hs /= $Precision

                                    if cube_hs < 0
                                        cube_hs *= -1
                                    end
                                    edge.halfsize += cube_hs
                                end
                            end
                        end
                        
                        edge.halfsize *= collider.halfsize
                        edge.halfsize /= $Precision
                        
                        hs_x = edge.x
                        if hs_x < 0
                            hs_x *= -1
                        end
                        hs_y = edge.y
                        if hs_y < 0
                            hs_y *= -1
                        end
                        hs_z = edge.z
                        if hs_z < 0
                            hs_z *= -1
                        end

                        edge.halfsize += (hs_x + hs_y + hs_z) / 2
                    end
                    
                    edge_axis++
                end
            end
        end
    end

    block_start_x = (collider.min_x + collider.max_pen) / $Precision * $Precision + $Half
    block_start_y = (collider.min_y + collider.max_pen) / $Precision * $Precision + $Half
    block_start_z = (collider.min_z + collider.max_pen) / $Precision * $Precision + $Half
    block_end_x = ((collider.max_x - collider.max_pen) / $Precision + 1) * $Precision
    block_end_y = ((collider.max_y - collider.max_pen) / $Precision + 1) * $Precision
    block_end_z = ((collider.max_z - collider.max_pen) / $Precision + 1) * $Precision
    
    for block_x = block_start_x to block_end_x by $Precision
        test_x = block_x / $Precision
        center_to_center.x = block_x - collider.x
        
        for block_y = block_start_y to block_end_y by $Precision
            test_y = block_y / $Precision
            center_to_center.y = block_y - collider.y
            
            for block_z = block_start_z to block_end_z by $Precision
                test_z = block_z / $Precision
                
                with
                    $(x) = test_x
                    $(y) = test_y
                    $(z) = test_z
                is_air()
                
                unless air
                    center_to_center.z = block_z - collider.z

                    continue = True
                    min_pen = $Billion
                    
                    for axis = 0 to 14
                        if continue
                            with
                                $(axis) = axis
                            do
                                define name separating_axis = "separating_axis_$(axis)"
                                
                                unless separating_axis.halfsize == 0
                                    pen = center_to_center.x * separating_axis.x
                                    pen += center_to_center.y * separating_axis.y
                                    pen += center_to_center.z * separating_axis.z
                                    pen /= $Precision
                                    axis_sign = 1
                                    
                                    if pen > 0
                                        pen *= -1
                                        axis_sign = -1
                                    end
                                    
                                    pen += separating_axis.halfsize
                                    
                                    if pen <= collider.max_pen
                                        if DebugCollisions
                                            tell @a "(test_x),(test_y),(test_z): Penetration (pen) less than (collider.max_pen) on axis (axis)"
                                        end
                                        continue = False
                                    else if pen <= 0
                                        if DebugCollisions
                                            tell @a "(test_x),(test_y),(test_z): Found separation of (pen) on axis (axis)"
                                        end
                                        continue = False
                                        axis = $Billion
                                    else if pen < min_pen
                                        min_pen = pen
                                        min_axis = axis
                                        min_axis_sign = axis_sign
                                    end
                                end
                            end
                        end
                    end
                    
                    if continue
                        if DebugCollisions
                            tell @a "(test_x),(test_y),(test_z): World penetration (min_pen) on axis (min_axis)"
                        end

                        id = get_unused_collision_id()
                        
                        # This collision surpasses the previous maximium penetration
                        collider.max_pen = min_pen
                        collider.max_pen_col = id

                       with
                            $(axis) = min_axis
                            $(collision) = id
                        do
                            define name axis = "separating_axis_$(axis)"
                            define name collision = "collision_$(collision)"
                            
                            collision.id = id
                            collision.pen = min_pen
                            
                            collision.collider1 = collider.id
                            
                            collision.nx = axis.x * min_axis_sign
                            collision.ny = axis.y * min_axis_sign
                            collision.nz = axis.z * min_axis_sign
                            
                            if min_axis < 3
                                collision.type = $CollisionCubeFaceWorldPoint
                                
                                if collision.nx > 0
                                    collision.x = block_x + $Half
                                end
                                if collision.nx <= 0
                                    collision.x = block_x - $Half
                                end
                                
                                if collision.ny > 0
                                    collision.y = block_y + $Half
                                end
                                if collision.ny <= 0
                                    collision.y = block_y - $Half
                                end
                                
                                if collision.nz > 0
                                    collision.z = block_z + $Half
                                end
                                if collision.nz <= 0
                                    collision.z = block_z - $Half
                                end
                                
                                
                                if min_axis == 0
                                    collision.lnx = min_axis_sign * $Precision
                                    collision.lny = 0
                                    collision.lnz = 0
                                end
                                if min_axis == 1
                                    collision.lnx = 0
                                    collision.lny = min_axis_sign * $Precision
                                    collision.lnz = 0
                                end
                                if min_axis == 2
                                    collision.lnx = 0
                                    collision.lny = 0
                                    collision.lnz = min_axis_sign * $Precision
                                end
                            else if min_axis < 6
                                collision.type = $CollisionCubePointWorldFace
                                
                                collision.block_x = block_x - $Half
                                collision.block_y = block_y - $Half
                                collision.block_z = block_z - $Half
                                
                                if min_axis == 3
                                    sign0 = -collider_a0.x * collision.nx
                                    sign1 = -collider_a1.x * collision.nx
                                    sign2 = -collider_a2.x * collision.nx
                                end
                                if min_axis == 4
                                    sign0 = -collider_a0.y * collision.ny
                                    sign1 = -collider_a1.y * collision.ny
                                    sign2 = -collider_a2.y * collision.ny
                                end
                                if min_axis == 5
                                    sign0 = -collider_a0.z * collision.nz
                                    sign1 = -collider_a1.z * collision.nz
                                    sign2 = -collider_a2.z * collision.nz
                                end
                                    
                                get_vertex_from_axis_signs()
                                
                                collision.vertex = vertex
                                with
                                    $(vertex) = vertex
                                do
                                    define name vertex = "collider_$(collider)_v$(vertex)"
                                    collision.x = vertex.x
                                    collision.y = vertex.y
                                    collision.z = vertex.z
                                end
                            else
                                collision.type = $CollisionCubeEdgeWorldEdge
                                
                                min_axis -= 6

                                collision.block_x = block_x - $Half
                                collision.block_y = block_y - $Half
                                collision.block_z = block_z - $Half
                                
                                block_axis = min_axis % 3
                                if block_axis == 0
                                    collision.ox = collision.block_x
                                    collision.ex = $Precision
                                    collision.ey = 0
                                    collision.ez = 0
                                    
                                    if collision.ny > 0
                                        collision.oy = collision.block_y + $Precision
                                    end
                                    if collision.ny <= 0
                                        collision.oy = collision.block_y
                                    end
                                    if collision.nz > 0
                                        collision.oz = collision.block_z + $Precision
                                    end
                                    if collision.nz <= 0
                                        collision.oz = collision.block_z
                                    end
                                end
                                if block_axis == 1
                                    collision.oy = collision.block_y
                                    collision.ex = 0
                                    collision.ey = $Precision
                                    collision.ez = 0
                                    
                                    if collision.nx > 0
                                        collision.ox = collision.block_x + $Precision
                                    end
                                    if collision.nx <= 0
                                        collision.ox = collision.block_x
                                    end
                                    if collision.nz > 0
                                        collision.oz = collision.block_z + $Precision
                                    end
                                    if collision.nz <= 0
                                        collision.oz = collision.block_z
                                    end
                                end                            
                                if block_axis == 2
                                    collision.oz = collision.block_z
                                    collision.ex = 0
                                    collision.ey = 0
                                    collision.ez = $Precision
                                    
                                    if collision.ny > 0
                                        collision.oy = collision.block_y + $Precision
                                    end
                                    if collision.ny <= 0
                                        collision.oy = collision.block_y
                                    end
                                    if collision.nx > 0
                                        collision.ox = collision.block_x + $Precision
                                    end
                                    if collision.nx <= 0
                                        collision.ox = collision.block_x
                                    end
                                end
                                
                                #tell @a "c2c: (center_to_center.x), (center_to_center.y), (center_to_center.z) sign: (min_axis_sign)"
                                #tell @a "n: (collision.nx), (collision.ny), (collision.nz)"
                                
                                axis = min_axis / 3
                                unless axis == 0
                                    sign0 = collision.nx * collider_a0.x + collision.ny * collider_a0.y + collision.nz * collider_a0.z
                                end
                                unless axis == 1
                                    sign1 = collision.nx * collider_a1.x + collision.ny * collider_a1.y + collision.nz * collider_a1.z
                                end
                                unless axis == 2
                                    sign2 = collision.nx * collider_a2.x + collision.ny * collider_a2.y + collision.nz * collider_a2.z
                                end
                                
                                sign0 *= -1
                                sign1 *= -1
                                sign2 *= -1
                                
                                #tell @a "block_axis:(block_axis) axis:(axis) signs:(sign0),(sign1),(sign2)"
                                
                                get_edge_from_signs()
                                collision.vertex1 = vertex
                                collision.vertex2 = nvert
                                
                                with
                                    $(vertex) = vertex
                                    $(nvert) = nvert
                                do
                                    define name vertex = "collider_$(collider)_v$(vertex)"
                                    define name nvert = "collider_$(collider)_v$(nvert)"
                                    get_closest_points_on_edges(vertex.x, vertex.y, vertex.z, nvert.x - vertex.x, nvert.y - vertex.y, nvert.z - vertex.z, collision.ox, collision.oy, collision.oz, collision.ex, collision.ey, collision.ez)
                                end
                                
                                collision.x = p1x
                                collision.y = p1y
                                collision.z = p1z
                            end
                        end
                    end
                end
            end
        end
    end
end

# Assumes separating_axis.xyz contains the normalized axis,
# called with $(collider)
function project_halfsize_onto_separating_axis()
    define name collider = "collider_$(collider)"
    
    projected = 0
    
    for axis_iter = 0 to 2
        with
            $(axis) = axis_iter
        do
            define name axis = "collider_$(collider)_a$(axis)"
            dot = (axis.x * separating_axis.x + axis.y * separating_axis.y + axis.z * separating_axis.z) / $Precision
            if dot < 0
                dot *= -1
            end
            
            projected += dot
        end
    end
    
    projected *= collider.halfsize
    projected /= $Precision
end

# Assumes separating_axis.xyz contains the normalized axis
# and center_to_center.xyz contains the vector from collider1 to collider2
# called with $(collider1) and $(collider2)
function test_axis_penetration()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    
    # Initialize the separation to be the distance between centers along the axis
    pen = (center_to_center.x * separating_axis.x + center_to_center.y * separating_axis.y + center_to_center.z * separating_axis.z) / $Precision
    axis_sign = 1
    
    if pen > 0
        pen *= -1
        axis_sign = -1
    end

    # Subtract collider1's halfsize along the axis from the separation
    with
        $(collider) = collider1.id
    project_halfsize_onto_separating_axis() with macros
    pen += projected
    
    # Subtract collider2's halfsize along the axis from the separation
    with
        $(collider) = collider2.id
    project_halfsize_onto_separating_axis() with macros
    pen += projected
    
    if pen <= pen_threshold
        # This collision will be smaller than both of the colliders' existing
        # max collisions.
        continue = False
    else if pen < min_pen
        min_pen = pen
        min_axis_idx = axis_idx
        min_axis_x = separating_axis.x
        min_axis_y = separating_axis.y
        min_axis_z = separating_axis.z
        min_axis_sign = axis_sign
    end
end

function get_min_separating_axis()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    
    if collider1.max_pen < collider2.max_pen
        pen_threshold = collider1.pen
    else
        pen_threshold = collider2.pen
    end
    
    min_pen = $Billion
    continue = True
    
    center_to_center.x = collider2.x - collider1.x
    center_to_center.y = collider2.y - collider1.y
    center_to_center.z = collider2.z - collider1.z
    
    dist_sq = center_to_center.x * center_to_center.x + center_to_center.y * center_to_center.y + center_to_center.z * center_to_center.z
    halfsize = collider1.halfsize + collider2.halfsize
    bsphere_sq = halfsize * halfsize / $Precision * 1732
    
    if dist_sq > bsphere_sq
        continue = False
    end
    
    for axis1 = 0 to 2
        if continue
            with
                $(axis) = axis1
            do
                define name axis = "collider_$(collider1)_a$(axis)"
                
                axis_idx = axis1
                separating_axis.x = axis.x
                separating_axis.y = axis.y
                separating_axis.z = axis.z
                
                test_axis_penetration() with macros
            end
        end
    end
    
    for axis2 = 0 to 2
        if continue
            with
                $(axis) = axis2
            do
                define name axis = "collider_$(collider2)_a$(axis)"
                
                axis_idx++
                separating_axis.x = axis.x
                separating_axis.y = axis.y
                separating_axis.z = axis.z
                
                test_axis_penetration() with macros
            end
        end
    end
    
    for axis1 = 0 to 2
        with
            $(axis1) = axis1
        do
            for axis2 = 0 to 2
                if continue
                    with
                        $(axis2) = axis2
                    do
                        axis_idx++
                        define name axis1 = "collider_$(collider1)_a$(axis1)"
                        define name axis2 = "collider_$(collider2)_a$(axis2)"
                        
                        separating_axis.x = (axis1.y * axis2.z - axis1.z * axis2.y) / $Precision
                        separating_axis.y = (axis1.z * axis2.x - axis1.x * axis2.z) / $Precision
                        separating_axis.z = (axis1.x * axis2.y - axis1.y * axis2.x) / $Precision
                        
                        magsq = separating_axis.x*separating_axis.x
                        magsq += separating_axis.y*separating_axis.y
                        magsq += separating_axis.z*separating_axis.z
                        
                        if magsq > 10
                            # The axes aren't parallel
                            mag = sqrt(magsq)
                            separating_axis.x *= $Precision
                            separating_axis.x /= mag
                            separating_axis.y *= $Precision
                            separating_axis.y /= mag
                            separating_axis.z *= $Precision
                            separating_axis.z /= mag
                            
                            test_axis_penetration() with macros
                        end
                    end
                end
            end
        end
    end
    
    if DebugCollisions
        if continue
            tell @a "Penetration of (min_pen) between (collider1.id) and (collider2.id) on axis #(min_axis_idx)"
        else
            tell @a "Found separation between (collider1.id) and (collider2.id) on axis #(axis_idx)"
        end
    end
end

function get_vertex_from_axis_signs()
    if sign0 > 0
        if sign1 > 0
            if sign2 > 0
                vertex = 0
            else
                vertex = 4
            end
        else
            if sign2 > 0
                vertex = 2
            else
                vertex = 6
            end
        end
    else
        if sign1 > 0
            if sign2 > 0
                vertex = 7
            else
                vertex = 3
            end
        else
            if sign2 > 0
                vertex = 5
            else
                vertex = 1
            end
        end    
    end
end

function get_edge_from_signs()
    if axis == 0
        if sign1 > 0
            if sign2 > 0
                vertex = 0
                nvert = 7
            else
                vertex = 3
                nvert = 4
            end
        else
            if sign2 > 0
                vertex = 2
                nvert = 5
            else
                vertex = 1
                nvert = 6
            end
        end    
    else if axis == 1
        if sign0 > 0
            if sign2 > 0
                vertex = 0
                nvert = 2
            else
                vertex = 4
                nvert = 6
            end
        else
            if sign2 > 0
                vertex = 5
                nvert = 7
            else
                vertex = 1
                nvert = 3
            end
        end    
    else
        # axis == 2
        if sign0 > 0
            if sign1 > 0
                vertex = 0
                nvert = 4
            else
                vertex = 2
                nvert = 6
            end
        else
            if sign1 > 0
                vertex = 3
                nvert = 7
            else
                vertex = 1
                nvert = 5
            end
        end       
    end
end
   
function get_collider_collider_collision()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"
     
    get_min_separating_axis() with macros
    
    if continue
        # Create the collision
        id = get_unused_collision_id()

        with
            $(collision) = id
        do            
            collision.id = id
            collision.pen = min_pen
            
            if min_pen > collider1.max_pen
                collider1.max_pen = min_pen
                collider1.max_pen_col = id
            end
            
            if min_pen > collider2.max_pen
                collider2.max_pen = min_pen
                collider2.max_pen_col = id
            end

            if min_axis_idx < 3
                # collider1 face, collider2 point
                # Get the collider1 face                
                if min_axis_idx == 0
                    lnx = min_axis_sign * $Precision
                    lny = 0
                    lnz = 0
                end
                if min_axis_idx == 1
                    lnx = 0
                    lny = min_axis_sign * $Precision
                    lnz = 0
                end
                if min_axis_idx == 2
                    lnx = 0
                    lny = 0
                    lnz = min_axis_sign * $Precision
                end
                
                define name axis0 = "collider_$(collider2)_a0"
                define name axis1 = "collider_$(collider2)_a1"
                define name axis2 = "collider_$(collider2)_a2"
                
                # Make the axis point toward collider1
                min_axis_x *= min_axis_sign
                min_axis_y *= min_axis_sign
                min_axis_z *= min_axis_sign
                   
                # Get the collider2 point
                sign0 = min_axis_x * axis0.x + min_axis_y * axis0.y + min_axis_z * axis0.z
                sign1 = min_axis_x * axis1.x + min_axis_y * axis1.y + min_axis_z * axis1.z
                sign2 = min_axis_x * axis2.x + min_axis_y * axis2.y + min_axis_z * axis2.z
                
                get_vertex_from_axis_signs()
                
                collision.collider1 = collider1.id
                collision.collider2 = collider2.id
                
                with
                    $(vertex) = vertex
                do
                    define name vertex = "collider_$(collider2)_v$(vertex)"

                    collision.x = vertex.x
                    collision.y = vertex.y
                    collision.z = vertex.z
                end
                    
                if DebugCollisions
                    tell @a "Creating collision with (collider1.id) face and (collider2.id) vertex"
                end

                collision.nx = min_axis_x
                collision.ny = min_axis_y
                collision.nz = min_axis_z

                collision.type = $CollisionCubeFaceCubePoint
                collision.lnx = lnx
                collision.lny = lny
                collision.lnz = lnz
                collision.vertex = vertex
            else if min_axis_idx < 6
                # collider1 point, collider2 face
                # Get the collider2 face                
                min_axis_sign *= -1
                
                if min_axis_idx == 3
                    lnx = min_axis_sign * $Precision
                    lny = 0
                    lnz = 0
                end
                if min_axis_idx == 4
                    lnx = 0
                    lny = min_axis_sign * $Precision
                    lnz = 0
                end
                if min_axis_idx == 5
                    lnx = 0
                    lny = 0
                    lnz = min_axis_sign * $Precision
                end
                
                define name axis0 = "collider_$(collider1)_a0"
                define name axis1 = "collider_$(collider1)_a1"
                define name axis2 = "collider_$(collider1)_a2"

                # Make the axis point toward collider2
                min_axis_x *= min_axis_sign
                min_axis_y *= min_axis_sign
                min_axis_z *= min_axis_sign

                # Get the collider1 point
                sign0 = min_axis_x * axis0.x + min_axis_y * axis0.y + min_axis_z * axis0.z
                sign1 = min_axis_x * axis1.x + min_axis_y * axis1.y + min_axis_z * axis1.z
                sign2 = min_axis_x * axis2.x + min_axis_y * axis2.y + min_axis_z * axis2.z
                
                get_vertex_from_axis_signs()
                
                collision.collider1 = collider2.id
                collision.collider2 = collider1.id
                
                with
                    $(vertex) = vertex
                do
                    define name vertex = "collider_$(collider1)_v$(vertex)"

                    collision.x = vertex.x
                    collision.y = vertex.y
                    collision.z = vertex.z
                end

                collision.nx = min_axis_x
                collision.ny = min_axis_y
                collision.nz = min_axis_z

                collision.type = $CollisionCubeFaceCubePoint
                collision.lnx = lnx
                collision.lny = lny
                collision.lnz = lnz
                collision.vertex = vertex

                if DebugCollisions
                    tell @a "Creating collision with (collider2.id) face and (collider1.id) vertex"
                    tell @a "Collision pen: (collision.pen) n: (collision.nx), (collision.ny), (collision.nz)"
                end
            else
                # edge, edge
                min_axis_idx -= 6
                
                # Get the collider1 edge
                define name axis0 = "collider_$(collider1)_a0"
                define name axis1 = "collider_$(collider1)_a1"
                define name axis2 = "collider_$(collider1)_a2"
                
                # Make the axis point toward collider1
                min_axis_x *= min_axis_sign
                min_axis_y *= min_axis_sign
                min_axis_z *= min_axis_sign

                axis = min_axis_idx / 3
                unless axis == 0
                    sign0 = min_axis_x * axis0.x + min_axis_y * axis0.y + min_axis_z * axis0.z
                end
                unless axis == 1
                    sign1 = min_axis_x * axis1.x + min_axis_y * axis1.y + min_axis_z * axis1.z
                end
                unless axis == 2
                    sign2 = min_axis_x * axis2.x + min_axis_y * axis2.y + min_axis_z * axis2.z
                end
                
                get_edge_from_signs()
                vertex1 = vertex
                nvert1 = nvert
                
                # Get the collider2 edge
                define name axis0 = "collider_$(collider2)_a0"
                define name axis1 = "collider_$(collider2)_a1"
                define name axis2 = "collider_$(collider2)_a2"

                axis = min_axis_idx % 3
                unless axis == 0
                    sign0 = min_axis_x * axis0.x + min_axis_y * axis0.y + min_axis_z * axis0.z
                end
                unless axis == 1
                    sign1 = min_axis_x * axis1.x + min_axis_y * axis1.y + min_axis_z * axis1.z
                end
                unless axis == 2
                    sign2 = min_axis_x * axis2.x + min_axis_y * axis2.y + min_axis_z * axis2.z
                end
                
                get_edge_from_signs()
                vertex2 = vertex
                nvert2 = nvert
                
                # Get the nearest points on the edges
                with
                    $(vertex1) = vertex1
                    $(nvert1) = nvert1
                    $(vertex2) = vertex2
                    $(nvert2) = nvert2
                do
                    define name vertex1 = "collider_$(collider1)_v$(vertex1)"
                    define name nvert1 = "collider_$(collider1)_v$(nvert1)"
                    define name vertex2 = "collider_$(collider2)_v$(vertex2)"
                    define name nvert2 = "collider_$(collider2)_v$(nvert2)"
                    
                    get_closest_points_on_edges(vertex1.x, vertex1.y, vertex1.z, nvert1.x - vertex1.x, nvert1.y - vertex1.y, nvert1.z - vertex1.z, vertex2.x, vertex2.y, vertex2.z, nvert2.x - vertex2.x, nvert2.y - vertex2.y, nvert2.z - vertex2.z)
                end
                
                if DebugCollisions
                    dx = p2x-p1x
                    dy = p2y-p1y
                    dz = p2z-p1z
                    mag = sqrt(dx*dx+dy*dy+dz*dz)

                    tell @a "Closest points are (mag) apart."
                    tell @a "Creating collision with (collider1.id) edge and (collider2.id) edge"
                end

                collision.collider1 = collider1.id
                collision.collider2 = collider2.id
                
                collision.x = p1x
                collision.y = p1y
                collision.z = p1z
                
                collision.nx = min_axis_x
                collision.ny = min_axis_y
                collision.nz = min_axis_z
                
                collision.type = $CollisionCubeEdgeCubeEdge
                collision.vertex1 = vertex1
                collision.nvert1 = nvert1
                collision.vertex2 = vertex2
                collision.nvert2 = nvert2
            end
        end
    end
end

function collider_physics_tick()
    define name collider = "collider_$(collider)"
    
    # Apply Gravity
    collider.velocity_y -= Gravity
    
    collider_integrate() with macros
    collider_quaternion_to_transform() with macros
end

function resolve_collision_velocity()
    collision_frame++
    
    for vel_iter = 1 to 20
        max_closing = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"
            
                if collision.active and collision.pen >= 0
                    with
                        $(collider1) = collision.collider1
                        $(collider2) = collision.collider2
                    do
                        define name collider1 = "collider_$(collider1)"
                        define name collider2 = "collider_$(collider2)"
                        
                        sleeping = True
                        unless collider1.sleeping
                            sleeping = False
                        end
                        
                        if collision.collider2 unless collider2.sleeping
                            sleeping = False
                        end
                        
                        if not sleeping                    
                            update_closing_velocity() with macros
                            
                            if collision.closing > max_closing
                                max_closing = collision.closing
                                max_closing_id = collision.id
                                max_closing_col1 = collision.collider1
                                max_closing_col2 = collision.collider2
                            end
                        end
                    end
                end
            end
        end
        
        if max_closing <= 5
            vel_iter = 1000000
        else
            with
                $(collision) = max_closing_id
                $(collider1) = max_closing_col1
                $(collider2) = max_closing_col2
            handle_collision_impulse()
        end
    end
end

function update_closing_velocity()
    define name collision = "collision_$(collision)"
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    
    /scoreboard players set Global twobody $(collider2)
    
    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z

    rot_lin_vel_x = (collider1.rotation_y * dz - collider1.rotation_z * dy + $Half) / $Precision
    rot_lin_vel_y = (collider1.rotation_z * dx - collider1.rotation_x * dz + $Half) / $Precision
    rot_lin_vel_z = (collider1.rotation_x * dy - collider1.rotation_y * dx + $Half) / $Precision
    
    collision.vel_x = collider1.velocity_x + rot_lin_vel_x
    collision.vel_y = collider1.velocity_y + rot_lin_vel_y
    collision.vel_z = collider1.velocity_z + rot_lin_vel_z

    if twobody
        dx = collision.x - collider2.x
        dy = collision.y - collider2.y
        dz = collision.z - collider2.z

        rot_lin_vel_x = (collider2.rotation_y * dz - collider2.rotation_z * dy + $Half) / $Precision
        rot_lin_vel_y = (collider2.rotation_z * dx - collider2.rotation_x * dz + $Half) / $Precision
        rot_lin_vel_z = (collider2.rotation_x * dy - collider2.rotation_y * dx + $Half) / $Precision
        
        collision.vel_x -= collider2.velocity_x + rot_lin_vel_x
        collision.vel_y -= collider2.velocity_y + rot_lin_vel_y
        collision.vel_z -= collider2.velocity_z + rot_lin_vel_z

    end
    
    collision.closing = -(collision.vel_x * collision.nx + collision.vel_y * collision.ny + collision.vel_z * collision.nz + $Half) / $Precision
end

function resolve_collision_penetration()
    for pen_iter = 1 to 20
        max_pen = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"

                if collision.active
                    with
                        $(collider1) = collision.collider1
                        $(collider2) = collision.collider2
                    do
                        define name collider1 = "collider_$(collider1)"
                        define name collider2 = "collider_$(collider2)"
                        
                        sleeping = True
                        unless collider1.sleeping
                            sleeping = False
                        end
                        
                        if collision.collider2 unless collider2.sleeping
                            sleeping = False
                        end
                        
                        if not sleeping and collision.pen > max_pen
                            max_pen = collision.pen
                            max_id = collision.id
                            max_pen_nx = collision.nx
                            max_pen_ny = collision.ny
                            max_pen_nz = collision.nz
                            max_pen_col1 = collision.collider1
                            max_pen_col2 = collision.collider2
                        end
                    end
                end
            end
        end
        
        if max_pen <= 5
            pen_iter = 1000000
        else
            mx = (max_pen_nx * max_pen) / $Precision
            my = (max_pen_ny * max_pen) / $Precision
            mz = (max_pen_nz * max_pen) / $Precision
            
            #tell @a "Resolving (max_pen_col1) and (max_pen_col2) with pen (max_pen), moving (mx), (my), (mz)"
            
            if not max_pen_col2
                with
                    $(collider) = max_pen_col1
                do
                    define name collider = "collider_$(collider)"
                    
                    if DebugCollisions
                        tell @a "#(pen_iter): Separating (collider.id)/world (mx), (my), (mz) from collision #(max_id)"
                    end
        
                    collider.x += mx
                    collider.y += my
                    collider.z += mz
                    
                    move_collisions(mx, my, mz, collider.id)
                end
            else
                with
                    $(collider1) = max_pen_col1
                    $(collider2) = max_pen_col2
                do
                    define name collider1 = "collider_$(collider1)"
                    define name collider2 = "collider_$(collider2)"
                    
                    if DebugCollisions
                        tell @a "#(pen_iter): Separating (collider1.id)/(collider2.id) (mx), (my), (mz) from collision #(max_id)"
                    end

                    inv_mass = collider1.inv_mass + collider2.inv_mass

                    p1 = collider1.inv_mass * $Precision / inv_mass
                    
                    m1x = p1 * mx / $Precision
                    m1y = p1 * my / $Precision
                    m1z = p1 * mz / $Precision
        
                    collider1.x += m1x 
                    collider1.y += m1y
                    collider1.z += m1z
                    if collider1.sleeping
                        with
                            $(collider) = collider1.id
                        collider_wake_up()
                    end
                    
                    move_collisions(m1x, m1y, m1z, collider1.id)
                    
                    p2 = -collider2.inv_mass * $Precision / inv_mass
                    
                    m2x = p2 * mx / $Precision
                    m2y = p2 * my / $Precision
                    m2z = p2 * mz / $Precision
        
                    collider2.x += m2x 
                    collider2.y += m2y
                    collider2.z += m2z
                    if collider2.sleeping
                        with
                            $(collider) = collider2.id
                        collider_wake_up()
                    end
                    
                    move_collisions(m2x, m2y, m2z, collider2.id)
                end
            end
        end
    end
end

function move_collisions(dx, dy, dz, collider)
    for collision = 1 to max_collision
        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            
            do_move = False
            if collision.collider1 == collider
                do_move = True
                sign = 1
            end
            if collision.collider2 == collider
                do_move = True
                sign = -1
            end
            
            if do_move
                collision.pen -= sign * (dx*collision.nx + dy*collision.ny + dz*collision.nz) / $Precision
            end
        end
    end
end

function is_air()
    air = False
    /execute if block $(x) $(y) $(z) minecraft:air run scoreboard players set Global air 1
end

function update_active_collisions()
    define name collision = "collision_$(collision)"

    # Clear the maximum penetration for each collider
    for collider_iter = 1 to max_collider
        with
            $(collider) = collider_iter
        do
            define name collider = "collider_$(collider)"

            if collider.id
                collider_calculate_vertex_world_positions() with macros
                collider.max_pen = 0
                collider.max_pen_col = 0
            end
        end
    end
    
    # Update each active collision
    for collision_iter = max_collision to 1 by -1
        with
            $(collision) = collision_iter
        do
            define name collision = "collision_$(collision)"
            if collision.active
                update_collision() with macros
            end
        end
    end
end

function update_collision()
    define name collision = "collision_$(collision)"
    define name collider = "collider_$(collider)"
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"

    if collision.type == $CollisionCubePointWorldFace
        with
            $(collider) = collision.collider1
        do
            with
                $(vertex) = collision.vertex
            do
                define name vertex = "collider_$(collider)_v$(vertex)"
                vx = vertex.x
                vy = vertex.y
                vz = vertex.z
            end
            
            keep = False
            
            if collision.nx == $Precision and vy >= collision.block_y and vy <= collision.block_y+$Precision and vz >= collision.block_z and vz <= collision.block_z+$Precision
                collision.pen = (collision.block_x + $Precision) - vx
                keep = True
            end
            if collision.nx == -$Precision and vy >= collision.block_y and vy <= collision.block_y+$Precision and vz >= collision.block_z and vz <= collision.block_z+$Precision
                collision.pen = vx - collision.block_x
                keep = True
            end
            if collision.ny == $Precision and vx >= collision.block_x and vx <= collision.block_x+$Precision and vz >= collision.block_z and vz <= collision.block_z+$Precision
                collision.pen = (collision.block_y + $Precision) - vy
                keep = True
            end
            if collision.ny == -$Precision and vx >= collision.block_x and vx <= collision.block_x+$Precision and vz >= collision.block_z and vz <= collision.block_z+$Precision
                collision.pen = vy - collision.block_y
                keep = True
            end
            if collision.nz == $Precision and vy >= collision.block_y and vy <= collision.block_y+$Precision and vx >= collision.block_x and vx <= collision.block_x+$Precision
                collision.pen = (collision.block_z + $Precision) - vz
                keep = True
            end
            
            if collision.nz == -$Precision and vy >= collision.block_y and vy <= collision.block_y+$Precision and vx >= collision.block_x and vx <= collision.block_x+$Precision
                collision.pen = vz - collision.block_z
                keep = True
            end
            
            if keep
                collision.x = vx
                collision.y = vy
                collision.z = vz
            else
                delete_collision() with macros
            end
        end
    end
    if collision.type == $CollisionCubeFaceWorldPoint
        with
            $(collider) = collision.collider1
        do
            # TODO: Check if the point is outside the bounds of the cube
            
            collider_world_to_local(collision.block_x, collision.block_y, collision.block_z, True) with macros
            
            keep = False
            if collision.lnx == $Precision and local_y >= -collider.halfsize and local_y <= collider.halfsize and local_z >= -collider.halfsize and local_z <= collider.halfsize
                collision.pen = local_x + collider.halfsize
                keep = True
            end
            if collision.lnx == -$Precision and local_y >= -collider.halfsize and local_y <= collider.halfsize and local_z >= -collider.halfsize and local_z <= collider.halfsize
                collision.pen = collider.halfsize - local_x
                keep = True
            end
            if collision.lny == $Precision and local_x >= -collider.halfsize and local_x <= collider.halfsize and local_z >= -collider.halfsize and local_z <= collider.halfsize
                collision.pen = local_y + collider.halfsize
                keep = True
            end
            if collision.lny == -$Precision and local_x >= -collider.halfsize and local_x <= collider.halfsize and local_z >= -collider.halfsize and local_z <= collider.halfsize
                collision.pen = collider.halfsize - local_y
                keep = True
            end
            if collision.lnz == $Precision and local_x >= -collider.halfsize and local_x <= collider.halfsize and local_y >= -collider.halfsize and local_y <= collider.halfsize
                collision.pen = local_z + collider.halfsize
                keep = True
            end
            if collision.lnz == -$Precision and local_x >= -collider.halfsize and local_x <= collider.halfsize and local_y >= -collider.halfsize and local_y <= collider.halfsize
                collision.pen = collider.halfsize - local_z
                keep = True
            end

            if keep
                collider_local_to_world(collision.lnx, collision.lny, collision.lnz, False) with macros
                collision.nx = world_x
                collision.ny = world_y
                collision.nz = world_z
            else
                delete_collision() with macros
            end
        end
    end
    if collision.type == $CollisionCubeEdgeWorldEdge
        with
            $(collider) = collision.collider1
        do
            with
                $(vertex) = collision.vertex1
            do
                define name vertex = "collider_$(collider)_v$(vertex)"
                ox = vertex.x
                oy = vertex.y
                oz = vertex.z
            end
            
            with
                $(vertex) = collision.vertex2
            do
                define name vertex = "collider_$(collider)_v$(vertex)"
                ex = vertex.x - ox
                ey = vertex.y - oy
                ez = vertex.z - oz
            end
            
            get_closest_points_on_edges(ox, oy, oz, ex, ey, ez, collision.ox, collision.oy, collision.oz, collision.ex, collision.ey, collision.ez)
            
            if t1 >= 0 and t1 <= $Precision and t2 >= 0 and t2 <= $Precision
                # The collision falls along the collider edges
                
                d1x = p1x - collider.x
                d1y = p1y - collider.y
                d1z = p1z - collider.z
                d1sq = d1x*d1x + d1y*d1y + d1z*d1z
                
                d2x = p2x - collider.x
                d2y = p2y - collider.y
                d2z = p2z - collider.z
                d2sq = d2x*d2x + d2y*d2y + d2z*d2z

                dx = p2x - p1x
                dy = p2y - p1y
                dz = p2z - p1z

                dist = sqrt(dx*dx + dy*dy + dz*dz)

                collider_world_to_local(p2x, p2y, p2z, True) with macros
                
                is_collision = False
                if p1x >= collision.block_x and p1y >= collision.block_y and p1z >= collision.block_z and p1x <= collision.block_x + $Precision and p1y <= collision.block_y + $Precision and p1z <= collision.block_z + $Precision
                    if local_x >= -collider.halfsize and local_x <= collider.halfsize and local_y >= -collider.halfsize and local_y <= collider.halfsize and local_z >= -collider.halfsize and local_z <= collider.halfsize
                        is_collision = True
                    end
                end
                
                if not is_collision
                    dist *= -1
                end
                    
                collision.pen = dist
                
                collision.x = p1x
                collision.y = p1y
                collision.z = p1z
                
                collision.nx = dx * $Precision / dist
                collision.ny = dy * $Precision / dist
                collision.nz = dz * $Precision / dist
            else
                delete_collision() with macros
            end
        end
    end
    if collision.type == $CollisionCubeFaceCubePoint
        with
            $(collider2) = collision.collider2
            $(vertex) = collision.vertex
        do
            define name v = "collider_$(collider2)_v$(vertex)"  
            vx = v.x
            vy = v.y
            vz = v.z
        end
    
        with
            $(collider1) = collision.collider1
        do        
            with
                $(collider) = collision.collider1
            collider_local_to_world(collision.lnx, collision.lny, collision.lnz, False)
            
            collision.nx = world_x
            collision.ny = world_y
            collision.nz = world_z
            
            collider_world_to_local(vx, vy, vz, True) with macros
            
            # TODO: Check if local_xyz lies within the bounds of the cube
            
            keep = False
                
            if collision.lnx == -$Precision and local_y >= -collider1.halfsize and local_y <= collider1.halfsize and local_z >= -collider1.halfsize and local_z <= collider1.halfsize
                collision.pen = collider1.halfsize - local_x
                keep = True
            end
            if collision.lnx == $Precision and local_y >= -collider1.halfsize and local_y <= collider1.halfsize and local_z >= -collider1.halfsize and local_z <= collider1.halfsize
                collision.pen = local_x + collider1.halfsize
                keep = True
            end
            if collision.lny == -$Precision and local_x >= -collider1.halfsize and local_x <= collider1.halfsize and local_z >= -collider1.halfsize and local_z <= collider1.halfsize
                collision.pen = collider1.halfsize - local_y
                keep = True
            end
            if collision.lny == $Precision and local_x >= -collider1.halfsize and local_x <= collider1.halfsize and local_z >= -collider1.halfsize and local_z <= collider1.halfsize
                collision.pen = local_y + collider1.halfsize
                keep = True
            end
            if collision.lnz == -$Precision and local_x >= -collider1.halfsize and local_x <= collider1.halfsize and local_y >= -collider1.halfsize and local_y <= collider1.halfsize
                collision.pen = collider1.halfsize - local_z
                keep = True
            end
            if collision.lnz == $Precision and local_x >= -collider1.halfsize and local_x <= collider1.halfsize and local_y >= -collider1.halfsize and local_y <= collider1.halfsize
                collision.pen = local_z + collider1.halfsize
                keep = True
            end
            
            if keep
                collision.x = vx
                collision.y = vy
                collision.z = vz
            else
                delete_collision() with macros
            end
        end
    end
    if collision.type == $CollisionCubeEdgeCubeEdge
        with
            $(collider1) = collision.collider1
            $(collider2) = collision.collider2
        do
            with
                $(v) = collision.vertex1
            do
                define name v = "collider_$(collider1)_v$(v)"
                o1x = v.x
                o1y = v.y
                o1z = v.z
            end
            with
                $(v) = collision.nvert1
            do
                define name v = "collider_$(collider1)_v$(v)"
                e1x = v.x - o1x
                e1y = v.y - o1y
                e1z = v.z - o1z
            end
            
            with
                $(v) = collision.vertex2
            do
                define name v = "collider_$(collider2)_v$(v)"
                o2x = v.x
                o2y = v.y
                o2z = v.z
            end
            with
                $(v) = collision.nvert2
            do
                define name v = "collider_$(collider2)_v$(v)"
                e2x = v.x - o2x
                e2y = v.y - o2y
                e2z = v.z - o2z
            end
            
            get_closest_points_on_edges(o1x, o1y, o1z, e1x, e1y, e1z, o2x, o2y, o2z, e2x, e2y, e2z)
            
            if t1 >= 0 and t1 <= $Precision and t2 >= 0 and t2 <= $Precision
                # The collision falls along the collider edges
                dx = p2x - p1x
                dy = p2y - p1y
                dz = p2z - p1z

                dist = sqrt(dx*dx + dy*dy + dz*dz)
                
                with
                    $(collider) = collider2.id
                collider_world_to_local(p1x, p1y, p1z, True)
                
                is_collision = False
                if local_x >= -collider2.halfsize and local_x <= collider2.halfsize and local_y >= -collider2.halfsize and local_y <= collider2.halfsize and local_z >= -collider2.halfsize and local_z <= collider2.halfsize
                    # The collision point falls within collider2
                    with
                        $(collider) = collider1.id
                    collider_world_to_local(p2x, p2y, p2z)
                    
                    if local_x >= -collider1.halfsize and local_x <= collider1.halfsize and local_y >= -collider1.halfsize and local_y <= collider1.halfsize and local_z >= -collider1.halfsize and local_z <= collider1.halfsize
                        # The collision point falls within collider1
                        is_collision = True
                    end
                end
                
                if not is_collision
                    dist *= -1
                end
                    
                collision.pen = dist
                
                collision.x = p1x
                collision.y = p1y
                collision.z = p1z
                
                collision.nx = dx * $Precision / dist
                collision.ny = dy * $Precision / dist
                collision.nz = dz * $Precision / dist
            else
                delete_collision() with macros
            end
        end
    end
    
    if collision.pen < -100
        delete_collision() with macros
    else
        with
            $(collider) = collision.collider1
        do
            if collision.pen > collider.max_pen
                collider.max_pen = collision.pen
            end
        end
        
        if collision.collider2
            with
                $(collider) = collision.collider2
            do
                if collision.pen > collider.max_pen
                    collider.max_pen = collision.pen
                end
            end
        end
    end
end

# Remove any new collisions that aren't the current max penetration for a collider
# as well as any that are equivalent to any already in the collision system.
function cull_collisions()
    define name collider = "collider_$(collider)"
    define name collision = "collision_$(collision)"

    # Find the maximum penetration for each collider
    for collision_iter = 1 to max_collision
        with
            $(collision) = collision_iter
        do
            if collision.id
                already_exists = False
                unless collision.active
                    for collision2_iter = 1 to max_collision
                        with
                            $(collision2) = collision2_iter
                        do
                            define name collision2 = "collision_$(collision2)"

                            if collision2.active
                                if collision.type == collision2.type
                                    if collision.type == $CollisionCubePointWorldFace
                                        if collision.vertex == collision2.vertex and collision.block_x == collision2.block_x and collision.block_y == collision2.block_y and collision.block_z == collision2.block_z
                                            already_exists = True
                                            collision2_iter = $Billion
                                        end
                                    end
                                    if collision.type == $CollisionCubeFaceWorldPoint
                                        if collision.x == collision2.x and collision.y == collision2.y and collision.z == collision2.z and collision.lnx == collision2.lnx and collision.lny == collision2.lny and collision.lnz == collision2.lnz
                                            already_exists = True
                                            collision2_iter = $Billion
                                        end
                                    end
                                    if collision.type == $CollisionCubeEdgeWorldEdge
                                        if collision.vertex1 == collision2.vertex1 and collision.vertex2 == collision2.vertex2 and collision.block_x == collision2.block_x and collision.block_y == collision2.block_y and collision.block_z == collision2.block_z and collision.ox == collision2.ox and collision.oy == collision2.oy and collision.oz == collision2.oz and collision.ex == collision2.ex and collision.ey == collision2.ey and collision.ez == collision2.ez
                                            already_exists = True
                                            collision2_iter = $Billion
                                        end
                                    end
                                    if collision.type == $CollisionCubeFaceCubePoint
                                        if collision.lnx == collision2.lnx and collision.lny == collision2.lny and collision.lnz == collision2.lnz and collision.vertex == collision2.vertex
                                            already_exists = True
                                            collision2_iter = $Billion
                                        end
                                    end
                                    if collision.type == $CollisionCubeEdgeCubeEdge
                                        if collision.vertex1 == collision2.vertex1 and collision.nvert1 == collision2.nvert1 and collision.vertex2 == collision2.vertex2 and collision.nvert2 == collision2.nvert2
                                            already_exists = True
                                            collision2_iter = $Billion
                                        end
                                    end
                                end
                            else
                                collision2_iter = $Billion
                            end
                        end
                    end
                end
                
                if already_exists
                    delete_collision() with macros
                end
            end
        end
    end
    
    # Set the highest penetration collision to active
    for collider_iter = 1 to max_collider
        with
            $(collider) = collider_iter
        do
            if collider.max_pen_col
                with
                    $(collision) = collider.max_pen_col
                do
                    collision.active = True
                end
            end
        end
    end
    
    # Delete any inactive collisions
    for collision_iter = max_collision to 1 by -1
        with
            $(collision) = collision_iter
        do
            if collision.id unless collision.active
                delete_collision() with macros
            end
        end
    end
end

# Compress the collisions so that they take up a continuous set of collision ids
function merge_collisions_down()
    free_collision = 0
    get_next_free_collision()
    
    for collision_iter = max_collision to 1 by -1
        with
            $(collision) = collision_iter
        do
            define name collision = "collision_$(collision)"

            if collision_iter <= free_collision
                collision_iter = 0
            else if collision.active
                with
                    $(free_collision) = free_collision
                do
                    define name free_collision = "collision_$(free_collision)"
                    
                    free_collision.id = free_collision
                    free_collision.active = True
                    free_collision.pen = collision.pen
                    
                    free_collision.x = collision.x
                    free_collision.y = collision.y
                    free_collision.z = collision.z
                    
                    free_collision.nx = collision.nx
                    free_collision.ny = collision.ny
                    free_collision.nz = collision.nz
                    
                    free_collision.type = collision.type
                    free_collision.collider1 = collision.collider1
                    free_collision.collider2 = collision.collider2
                    free_collision.vertex = collision.vertex
                    free_collision.vertex1 = collision.vertex1
                    free_collision.vertex2 = collision.vertex2
                    free_collision.nvert1 = collision.nvert1
                    free_collision.nvert2 = collision.nvert2
                    free_collision.block_x = collision.block_x
                    free_collision.block_y = collision.block_y
                    free_collision.block_z = collision.block_z
                    free_collision.lnx = collision.lnx
                    free_collision.lny = collision.lny
                    free_collision.lnz = collision.lnz
                    free_collision.ox = collision.ox
                    free_collision.oy = collision.oy
                    free_collision.oz = collision.oz
                    free_collision.ex = collision.ex
                    free_collision.ey = collision.ey
                    free_collision.ez = collision.ez
                    
                    /scoreboard players reset collision_$(collision)
                    
                    get_next_free_collision()
                end
            end
        end
    end
    
    max_collision = free_collision - 1
end

function get_next_free_collision()
    continue = True
    while continue
        free_collision++
        
        with
            $(free_collision) = free_collision
        do
            define name free_collision = "collision_$(free_collision)"
            unless free_collision.id
                continue = False
            end
        end
    end
end

function get_unused_collision_id()
    unused_id = -1

    for collision = 1 to 200
        exists = False

        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            unless collision.id
                unused_id = collision
                collision.id = collision

                if collision > max_collision
                    max_collision = collision
                end

                collision = 1000000
            end
        end
    end
    
    return unused_id
end

function delete_collisions()
    for collision = max_collision to 1 by -1
        with
            $(collision) = collision
        delete_collision()
    end
    
    max_collision = 0
end

function delete_collision()
    define name collision = "collision_$(collision)"
    if collision.id
        if collision.id == max_collision
            max_collision--
        end

        /scoreboard players reset collision_$(collision)
    end
end

# Initializes contact transform, and impulse <--> velocity matrices
function initialize_collision_matrices()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"

    # Create contact basis/transform
    collision.ct_01 = collision.nx
    collision.ct_11 = collision.ny
    collision.ct_21 = collision.nz
    
    absx = abs(collision.nx)
    absz = abs(collision.nz)
    
    if absx < absz
        # The norm isn't pointing toward x, so
        # cross the norm with 1,0,0
        s = sqrt(collision.ny*collision.ny + collision.nz*collision.nz)
        collision.ct_00 = 0
        collision.ct_10 = -collision.nz * $Precision / s
        collision.ct_20 = collision.ny * $Precision / s

        # Cross the norm with the new vector
        collision.ct_02 = (collision.ct_10*collision.ct_21 - collision.ct_20*collision.ct_11) / $Precision
        collision.ct_12 = (collision.ct_20*collision.ct_01) / $Precision
        collision.ct_22 = (collision.ct_10*collision.ct_01) / $Precision
    else
        # The norm isn't pointing toward z, so
        # cross the norm with 0,0,1
        s = sqrt(collision.ny*collision.ny + collision.nx*collision.nx)
        collision.ct_00 = collision.ny * $Precision / s
        collision.ct_10 = -collision.nx * $Precision / s
        collision.ct_20 = 0

        # Cross the norm with the new vector
        collision.ct_02 = (collision.ct_10*collision.ct_21) / $Precision
        collision.ct_12 = (collision.ct_00*collision.ct_21) / $Precision
        collision.ct_22 = (collision.ct_00*collision.ct_11 - collision.ct_10*collision.ct_01) / $Precision
    end

    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z
    
    # Impulse to velocity transform
    # Formula: -(i_to_t^2) * InverseRotationalIntertia
    i_to_v_00 = ((dz * dz + dy * dy) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_01 = ((-dy * dx) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_02 = ((-dz * dx) / $Precision * collider1.inv_rot_int) / $Precision

    i_to_v_10 = ((-dx * dy) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_11 = ((dz * dz + dx * dx) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_12 = ((-dz * dy) / $Precision * collider1.inv_rot_int) / $Precision

    i_to_v_20 = ((-dx * dz) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_21 = ((-dy * dz) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_22 = ((dy * dy + dx * dx) / $Precision * collider1.inv_rot_int) / $Precision
    
    # Transform i_to_v into contact coordinates before inverting,
    # using change of basis formula
    
    # First, ct^transpose * i_to_v
    with
        $(m1) = "collision_$(collision) ct"
        $(m2) = "Global i_to_v"
        $(out) = "Global m"
    transpose_matrix_multiply()

    # Then, multiply by ct
    with
        $(m1) = "Global m"
        $(m2) = "collision_$(collision) ct"
        $(out) = "collision_$(collision) c_i_to_v"
    matrix_multiply()
    
    inv_mass = collider1.inv_mass
    
    if twobody
        dx = collision.x - collider2.x
        dy = collision.y - collider2.y
        dz = collision.z - collider2.z

        # Impulse to velocity transform
        # Formula: -(i_to_t^2) * InverseRotationalIntertia
        i_to_v_00 = ((dz * dz + dy * dy) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_01 = ((-dy * dx) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_02 = ((-dz * dx) / $Precision * collider2.inv_rot_int) / $Precision

        i_to_v_10 = ((-dx * dy) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_11 = ((dz * dz + dx * dx) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_12 = ((-dz * dy) / $Precision * collider2.inv_rot_int) / $Precision

        i_to_v_20 = ((-dx * dz) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_21 = ((-dy * dz) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_22 = ((dy * dy + dx * dx) / $Precision * collider2.inv_rot_int) / $Precision
        
        # Transform i_to_v into contact coordinates before inverting,
        # using change of basis formula
        
        # First, ct^transpose * i_to_v
        with
            $(m1) = "collision_$(collision) ct"
            $(m2) = "Global i_to_v"
            $(out) = "Global m"
        transpose_matrix_multiply()

        # Then, multiply by ct
        with
            $(m1) = "Global m"
            $(m2) = "collision_$(collision) ct"
            $(out) = "Global c_i_to_v_2"
        matrix_multiply()
        
        collision.c_i_to_v_00 += c_i_to_v_2_00
        collision.c_i_to_v_01 += c_i_to_v_2_01
        collision.c_i_to_v_02 += c_i_to_v_2_02
        collision.c_i_to_v_10 += c_i_to_v_2_10
        collision.c_i_to_v_11 += c_i_to_v_2_11
        collision.c_i_to_v_12 += c_i_to_v_2_12
        collision.c_i_to_v_20 += c_i_to_v_2_20
        collision.c_i_to_v_21 += c_i_to_v_2_21
        collision.c_i_to_v_22 += c_i_to_v_2_22
        
        inv_mass += collider2.inv_mass
    end
    
    # In contact space, add the inverse mass to the diagonal
    collision.c_i_to_v_00 += inv_mass
    collision.c_i_to_v_11 += inv_mass
    collision.c_i_to_v_22 += inv_mass

    a = collision.c_i_to_v_00
    b = collision.c_i_to_v_01
    c = collision.c_i_to_v_02

    d = collision.c_i_to_v_10
    e = collision.c_i_to_v_11
    f = collision.c_i_to_v_12

    g = collision.c_i_to_v_20
    h = collision.c_i_to_v_21
    i = collision.c_i_to_v_22
    
    # Inverse impulse to velocity
    det =  (a * e) / $Precision * i
    det += (d * h) / $Precision * c
    det += (g * b) / $Precision * f
    det -= (a * h) / $Precision * f
    det -= (g * e) / $Precision * c
    det -= (d * b) / $Precision * i
    det /= $Precision

    collision.v_to_i_00 = (e * i - f * h) / det
    collision.v_to_i_01 = (c * h - b * i) / det
    collision.v_to_i_02 = (b * f - c * e) / det

    collision.v_to_i_10 = (f * g - d * i) / det
    collision.v_to_i_11 = (a * i - c * g) / det
    collision.v_to_i_12 = (c * d - a * f) / det

    collision.v_to_i_20 = (d * h - e * g) / det
    collision.v_to_i_21 = (b * g - a * h) / det
    collision.v_to_i_22 = (a * e - b * d) / det
    
    collision.initialized = collision_frame
end

function handle_collision_impulse()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"
    
    /scoreboard players set Global twobody $(collider2)
    
    unless collision.initialized == collision_frame
        initialize_collision_matrices() with macros
    end
    
    # Transform by the ct transpose matrix to get the closing velocity in contact coordinates
    c_vel_x = (collision.ct_00 * collision.vel_x + collision.ct_10 * collision.vel_y + collision.ct_20 * collision.vel_z + $Half) / $Precision
    c_vel_y = (collision.ct_01 * collision.vel_x + collision.ct_11 * collision.vel_y + collision.ct_21 * collision.vel_z + $Half) / $Precision
    c_vel_z = (collision.ct_02 * collision.vel_x + collision.ct_12 * collision.vel_y + collision.ct_22 * collision.vel_z + $Half) / $Precision
    
    restitution = Restitution
    if c_vel_y > $CancelRestitution
        restitution = 0
    end
    
    desired_vx = 0
    # TODO: Add gravity in the positive Y world direction
    desired_vy = (-(c_vel_y) * restitution) / $Precision
    desired_vz = 0

    desired_dvx = desired_vx - c_vel_x
    desired_dvy = desired_vy - c_vel_y
    desired_dvz = desired_vz - c_vel_z
    
    cix = (collision.v_to_i_00 * desired_dvx + collision.v_to_i_01 * desired_dvy + collision.v_to_i_02 * desired_dvz + $Half) / $Precision
    ciy = (collision.v_to_i_10 * desired_dvx + collision.v_to_i_11 * desired_dvy + collision.v_to_i_12 * desired_dvz + $Half) / $Precision
    ciz = (collision.v_to_i_20 * desired_dvx + collision.v_to_i_21 * desired_dvy + collision.v_to_i_22 * desired_dvz + $Half) / $Precision
    
    planar_impulse = sqrt(cix*cix + ciz*ciz)
    
    $Friction = 800
    max_fric_impulse = (ciy * $Friction + $Half) / $Precision
    
    if planar_impulse > max_fric_impulse
        dir_ix = cix * $Precision / planar_impulse
        dir_iz = ciz * $Precision / planar_impulse
    
        v_per_i_y = collision.c_i_to_v_11 + ((collision.c_i_to_v_10 * dir_ix + collision.c_i_to_v_12 * dir_iz + $Half) / $Precision * $Friction + $Half) / $Precision
        
        ciy = desired_dvy * $Precision / v_per_i_y
        
        cix = ((dir_ix * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
        ciz = ((dir_iz * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
    end
    
    # Transform impulse vector out of contact coordinates
    ix = (collision.ct_00 * cix + collision.ct_01 * ciy + collision.ct_02 * ciz + $Half) / $Precision
    iy = (collision.ct_10 * cix + collision.ct_11 * ciy + collision.ct_12 * ciz + $Half) / $Precision
    iz = (collision.ct_20 * cix + collision.ct_21 * ciy + collision.ct_22 * ciz + $Half) / $Precision
    
    # collider1.id isn't using define name
    with
        $(collider) = collider1.id
    collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    
    if twobody
        ix *= -1
        iy *= -1
        iz *= -1
        
        with
            $(collider) = collider2.id
        collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    end
end