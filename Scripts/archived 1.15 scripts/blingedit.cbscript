dir "C:\Users\Seth\AppData\Roaming\.minecraft 1.14\saves\SethBling's World 1.14"
desc "GUI for performing Minecraft world editing operations."

# Player edit state constants
$Closed = 0
$Pick1 = 1
$EditSource = 3
$EditingSource = 4
$FillWait = 5
$ReplaceWait1 = 6
$ReplaceWait2 = 7
$EditDest = 8
$MovingDest = 9
$ReplaceWaitRandom = 10
$CloneBrush = 11
$PluginClick = 12

# Corner type constants
$Type_Source = 1
$Type_Dest = 2

define block_tag cursor_continue
    air
    water
    cave_air
end

import random
import left_right_click_detector

define @Corner = @Entity[type=magma_cube,tag=Corner]
    create {CustomName:"\"Corner\"", Tags:["Corner"], Glowing:1b, NoGravity:1b, NoAI:1b, Invulnerable:1b, Size:1b, Silent:1b, AbsorptionAmount:100f}
    time: Time byte 1
end

define @CloneDisplay = @Entity[type=armor_stand,tag=CloneDisplay]
    create {CustomName:"\"CloneDisplay\"", Tags:["CloneDisplay"], Glowing:1b, NoGravity:1b, NoAI: 1b, Silent:1b, AbsorptionAmount: 100f, LeftHanded:0b, Invulnerable:1, ShowArms:1b, Pose:{LeftArm:[-90f,0f,0f],RightArm:[-90f,0f,0f]}}

	function replace_items()
		if @s.left_handed
			/replaceitem entity @s weapon.offhand diamond_sword
			/replaceitem entity @s weapon.mainhand shield
		else
			/replaceitem entity @s weapon.mainhand diamond_sword
			/replaceitem entity @s weapon.offhand shield
		end
	end


	function clone_flip_horizontal()
		if flip_x
            lh = @s.left_handed
            if lh then @s.left_handed = False
            unless lh then @s.left_handed = True
			@s.replace_items()
		end
		if flip_z
            lh = @s.left_handed
            if lh then @s.left_handed = False
            unless lh then @s.left_handed = True
			@s.replace_items()
            @s.ry += 180000
		end
	end
end

define @Player = @Entity[type=player]
    selected: SelectedItemSlot int 1
	pick1: @Corner
	pick2: @Corner
	from_display: @CloneDisplay
	to_display: @CloneDisplay
	moving: @Corner

    function tell_actions()
        tell @s ''
        tell @s 'BlingEdit: {C[\[Options\]](/function blingedit:options) {B[\[Help\]](https://docs.google.com/document/d/13jC-XnCvyyaTaVWAqNc3Gyqu6JEOWAa-xGfhFC8AU50/edit?usp=sharing)'
        tell @s 'Move {RBox{w: {C[\[Up\]](/function blingedit:move_up) [\[Down\]](/function blingedit:move_down) [\[Left\]](/function blingedit:move_left) [\[Right\]](/function blingedit:move_right) [\[Forward\]](/function blingedit:move_forward) [\[Backward\]](/function blingedit:move_backward)'
        tell @s 'Actions: {G[\[Clone\]](/function blingedit:clone) {y[\[Fill\]](/function blingedit:fill) {Y[\[Replace\]](/function blingedit:replace) {C[\[Random\]](/function blingedit:randomize_menu) {M[\[Plugin\]](/function blingedit:list_plugins)   {R[\[Delete\]](/function blingedit:delete)'
    end

    function options()
        tell @s ''
        tell @s 'BlingEdit Options:'
        tell @s 'Region Particle Outline: {G[\[On\]](/function blingedit:particles_on) {R[\[Off\]](/function blingedit:particles_off)'
        /gamerule sendCommandFeedback false
    end

    function particles_on()
        tell @s 'Region Outline Particles {Genabled{-.'
        @s.particles = True
        /gamerule sendCommandFeedback false
    end

    function particles_off()
        tell @s 'Region Outline Particles {Rdisabled{-'
        @s.particles = False
        /gamerule sendCommandFeedback false
    end

    function get_cursor_position()
        if @s.raycast_select
            @Player.cursor_current = False
            @s.cursor_current = True
            @player = @Player[cursor_current,limit=1]
            at @s
				unless @Position do create @Position
				/tp @Position @s
				move @Position ~ ~1.6 ~

				step = 0
				if @s.cursor_inside
					while step < 250 at @Position if block ~ ~ ~ cursor_continue
						move @Position ^ ^ ^0.2
						step++
					end
				else
					while step < 250 at @Position if block ^ ^ ^0.2 cursor_continue
						move @Position ^ ^ ^0.2
						step++
					end
				end

				at @Position align xyz at ~0.5 ~ ~0.5
					/tp @Position ~ ~ ~
				end
				<cursor> = @Position.<pos>
            end
        end

		if i == 5
			i = 5
		end

        unless @s.raycast_select
            if @s.cursor_range == 5
                at @s ~ ~1.6 ~ at ^ ^ ^5 align xyz at ~0.5 ~ ~0.5
                    <cursor> = here
                end
            end
            if @s.cursor_range == 10
                at @s ~ ~1.6 ~ at ^ ^ ^10 align xyz at ~0.5 ~ ~0.5
                    <cursor> = here
                end
            end
            if @s.cursor_range == 15
                at @s ~ ~1.6 ~ at ^ ^ ^15 align xyz at ~0.5 ~ ~0.5
                    <cursor> = here
                end
            end
            if @s.cursor_range == 20
                at @s ~ ~1.6 ~ at ^ ^ ^20 align xyz at ~0.5 ~ ~0.5
                    <cursor> = here
                end
            end
        end
    end

    function cursor_range_5()
        @s.cursor_range = 5
        tell @s 'Set cursor range to {G5'
        /gamerule sendCommandFeedback false
    end

    function cursor_range_10()
        @s.cursor_range = 10
        tell @s 'Set cursor range to {G10'
        /gamerule sendCommandFeedback false
    end

    function cursor_range_15()
        @s.cursor_range = 15
        tell @s 'Set cursor range to {G15'
        /gamerule sendCommandFeedback false
    end

    function cursor_range_20()
        @s.cursor_range = 20
        tell @s 'Set cursor range to {G20'
        /gamerule sendCommandFeedback false
    end

    function cursor_inside()
        @s.cursor_inside = True
        tell @s 'Set cursor raycast to stop {GInside Blocks'
        /gamerule sendCommandFeedback false
    end

    function cursor_before()
        @s.cursor_inside = False
        tell @s 'Set cursor raycast to stop just {GBefore Blocks'
        /gamerule sendCommandFeedback false
    end

    function get_minmax()
        has_box = -1

        as @s.pick1
            <x1, y1, z1> = @s.<pos>
            has_box++
        end
        as @s.pick2
            <x2, y2, z2> = @s.<pos>
            has_box++
        end

        if x1 < x2
            xmin = x1
            xmax = x2
        end
        if x1 >= x2
            xmin = x2
            xmax = x1
        end
        if y1 < y2
            ymin = y1
            ymax = y2
        end
        if y1 >= y2
            ymin = y2
            ymax = y1
        end
        if z1 < z2
            zmin = z1
            zmax = z2
        end
        if z1 >= z2
            zmin = z2
            zmax = z1
        end

        <min> = <xmin, ymin, zmin>
        <max> = <xmax, ymax, zmax>
        <size> = <max> - <min>

        <box_xmin, box_ymin, box_zmin> = <min> / 1000
        <box_xmax, box_ymax, box_zmax> = <max> / 1000
        <box_center_x, box_center_y, box_center_z> = (<min> + <max>) / 2 / scale
        <box_size_x, box_size_y, box_size_z> = <size> / scale + <1, 1, 1>
    end

    function get_dest_minmax()
        player = &@s
        has_dest_box = False

        first = True
        as @Corner if @s.player == player and @s.type == $Type_Dest
            if first
                has_dest_box = True
                <dest_xmin, dest_ymin, dest_zmin> = @s.<pos>
                first = False
            end
            <x, y, z> = @s.<pos>
            if x < dest_xmin then dest_xmin = x
            if y < dest_ymin then dest_ymin = y
            if z < dest_zmin then dest_zmin = z
        end

        <dest_min> = <dest_xmin, dest_ymin, dest_zmin>

        first = True
        as @Corner if @s.player == player and @s.type == $Type_Dest
            if first
                <dest_xmax, dest_ymax, dest_zmax> = @s.<pos>
                first = False
            end
            <x, y, z> = @s.<pos>
            if x > dest_xmax then dest_xmax = x
            if y > dest_ymax then dest_ymax = y
            if z > dest_zmax then dest_zmax = z
        end

        <dest_max> = <dest_xmax, dest_ymax, dest_zmax>
    end

    function clone_air()
        @s.clone_air = True
        tell @s 'Clone air: {GEnabled'

        /gamerule sendCommandFeedback false
    end

    function dont_clone_air()
        @s.clone_air = False
        tell @s 'Clone air: {RDisabled'

        /gamerule sendCommandFeedback false
    end

	function toggle_clone_in_place()
		if @s.clone_in_place
			@s.clone_in_place = False
		else
			@s.clone_in_place = True
		end
		@s.cancel()
		@s.clone()

		/gamerule sendCommandFeedback false
	end

    function clone_flip_leftright()
		ry = (@s.ry/scale + @s.clone_rotation) % 360
		flip_x = False
		flip_z = False

		if ry < 45
			flip_x = True
		end
		if ry >= 45 and ry < 135
			flip_z = True
		end
		if ry >= 135 and ry < 225
			flip_x = True
		end
		if ry >= 225 and ry < 315
			flip_z = True
		end
		if ry >= 315
			flip_x = True
		end

		@s.invert_clone_flip()

        as @s.to_display
			@s.clone_flip_horizontal()
        end
        /gamerule sendCommandFeedback false
    end

    function clone_flip_frontback()
		ry = (@s.ry/scale + @s.clone_rotation) % 360

		flip_x = False
		flip_z = False

		if ry < 45
			flip_z = True
		end
		if ry >= 45 and ry < 135
			flip_x = True
		end
		if ry >= 135 and ry < 225
			flip_z = True
		end
		if ry >= 225 and ry < 315
			flip_x = True
		end
		if ry >= 315
			flip_z = True
		end

		@s.invert_clone_flip()

		as @s.to_display
			@s.clone_flip_horizontal()
        end
        /gamerule sendCommandFeedback false
    end

	function invert_clone_flip_x()
		if flip_x
			if @s.clone_flip_x
				@s.clone_flip_x = False
			else
				@s.clone_flip_x = True
			end
		end
		if flip_z
			if @s.clone_flip_z
				@s.clone_flip_z = False
			else
				@s.clone_flip_z = True
			end
		end
	end


    function clone_rotate_left()
		@s.clone_rotation -= 90
		if @s.clone_rotation < 0
			@s.clone_rotation += 360
		end
        as @s.to_display
            @s.ry -= 90000
        end
		@s.rotate_dest_horizontal()

        /gamerule sendCommandFeedback false
    end

    function clone_rotate_right()
		@s.clone_rotation += 90
		if @s.clone_rotation >= 360
			@s.clone_rotation -= 360
		end
        as @s.to_display
            @s.ry += 90000
        end
		@s.rotate_dest_horizontal()

        /gamerule sendCommandFeedback false
    end

	function rotate_dest_horizontal()
		@s.get_dest_minmax()
		clone_rotation = @s.clone_rotation

		<cx, cy, cz> = (<dest_min> + <dest_max>) / 2

		<sx, sy, sz> = <dest_max> - <dest_min>
		mod = (cx + cz) % scale

		x_offset = 0
		z_offset = 0
		unless mod == 0
			x_offset = 500
			if clone_rotation == 90 then x_offset = -500
			if clone_rotation == 180 then x_offset = -500

			z_offset = 500
			if clone_rotation == 180 then z_offset = -500
			if clone_rotation == 270 then z_offset = -500
		end


		player = &@s
		as @Corner if @s.player == player and @s.type == $Type_Dest
			dx = cx - @s.x
			dz = cz - @s.z

			@s.x = cx - dz + x_offset
			@s.z = cz - dx + z_offset
		end
	end

    function plugin_can_run()
        plugin_can_run = False
        if @s.state == $EditSource
            @s.get_minmax()
            if has_box
                plugin_can_run = True
            end
        end
    end

    function list_plugins()
        @s.prime_plugins = True

        /gamerule sendCommandFeedback false
    end

    function randomize_menu()
        tell @s ''
        tell @s '{cRandomization Options:'
        tell @s '{C[\[Store Selected Region as Random Block Pool\]](/function blingedit:store_random)'
        tell @s '{C[\[Fill Selected Region from Random Block Pool\]](/function blingedit:fill_random)'
        tell @s '{C[\[Replace in Selected Region from Random Block Pool\]](/function blingedit:replace_random)'

        /gamerule sendCommandFeedback false
    end

    function store_random()
        unless @s.state == $EditSource
            tell @s "You can't store a region right now."
        end
        if @s.state == $EditSource
            @s.get_minmax()
            if has_box
                @s.<rand_min> = <min> / scale
                @s.<rand_max> = <max> / scale
                @s.has_rand = True

                <rx1, ry1, rz1> = @s.<rand_min>
                <rx2, ry2, rz2> = @s.<rand_max>
                tell @s 'Random Block Pool region stored as \((rx1), (ry1), (rz1)\) to \((rx2), (ry2), (rz2)\)'
			else
				tell @s "You don't currently have a region selected."
            end
        end

        /gamerule sendCommandFeedback false
    end

    function fill_random()
        if @s.state == $EditSource
            unless @s.has_rand
                tell @s "You haven't selected a region for a random block pool yet."
            end
            if @s.has_rand
                check_loaded()

                if loaded
                    @s.get_minmax()
                    if has_box
                        replaced_blocks = 0

                        <rx1, ry1, rz1> = @s.<rand_min>
                        <rx2, ry2, rz2> = @s.<rand_max>

						<rand_min> = @s.<rand_min>
                        random_replace = @s.random_replace
                        /bossbar set progress players @s
                        store_tile_drops()

						unless @Position do create @Position
						unless @Position2 do create @Position2

                        as @Position
                            for x = xmin to xmax by scale
                                percent = (x - xmin) * 100 / (xmax - xmin)
                                /execute store result bossbar progress value run scoreboard players get Global percent

                                for z = zmin to zmax by scale
                                    for y = ymin to ymax by scale
                                        @s.<pos> = <x, y, z>
                                        at @s
                                            if random_replace
                                                replace = False
                                                /execute if blocks ~ ~ ~ ~ ~ ~ 0 2 0 all run scoreboard players set Global replace 1
                                            else
                                                replace = True
                                            end
                                            if replace
												rx = randint(rx1, rx2+1)
                                                ry = randint(ry1, ry2+1)
                                                rz = randint(rz1, rz2+1)

												@Position2.<pos> = <rx, ry, rz> * scale
												<tx, ty, tz> = @Position2.<pos>
												at @Position2
                                                    /clone ~ ~ ~ ~ ~ ~ 0 1 0
                                                end

                                                replaced_blocks++
                                                /clone 0 1 0 0 1 0 ~ ~ ~
                                            end
                                        end
                                    end
                                end
                            end
                            /kill @s
                        end
                        restore_tile_drops()
                    end
                end
            end
		else
			tell @s "You can't store a region right now."
        end

        /gamerule sendCommandFeedback false
    end

    function replace_random()
        @s.state = $ReplaceWaitRandom
        tell @s 'Use {w[/setblock ~ ~ ~ <block>](//setblock ~ ~ ~ minecraft:){- to pick the blocks to replace.'
        tell @s 'Or replace {C[\[air\]](/function blingedit:replace_random_air)'

        /gamerule sendCommandFeedback false
    end

    function replace_random_air()
        /setblock 0 2 0 air
        perform_random_replace()

        /gamerule sendCommandFeedback false
    end

    function perform_random_replace()
        @s.random_replace = True
        @s.state = $EditSource

        @s.fill_random()

        @s.random_replace = False
        tell @s 'Replaced (replaced_blocks) blocks.'
    end

    function clone()
        if @s.state == $EditSource
            @s.get_minmax()

            unless has_box
                tell @s "You don't currently have a region selected."
            end
            if has_box
                <dx, dy, dz> = <max> - <min>
                <center> = (<max> + <min>) / 2
                <center> -= <center> % scale + <scale/2, 0, scale/2>

                player = &@s
                @s.get_cursor_position()
				if @s.clone_in_place
					<cursor> = <center>
				end

                as @Corner if @s.player == player and @s.type == $Type_Source
                    <dpos> = @s.<pos> - <center>
                    bottom_center = False
                    if @s.center_x and @s.center_z and @s.y == ymin
                        bottom_center = True
                    end

                    as create @Corner
                        @s.type = $Type_Dest
                        @s.<pos> = <cursor> + <dpos>
                        /team join dest
                        @s.player = player
                        if bottom_center
                            moving = &@s
                            @s.bottom_center = True
                        end
                    end
                end

                move @Corner ~ ~ ~

				if @s.clone_in_place
					@s.state = $EditDest
				end

				unless @s.clone_in_place
					@s.moving = moving
					@s.state = $MovingDest
					@s.enable_click()
				end

                @s.from_display = create @CloneDisplay
                as @s.from_display
                    /replaceitem entity @s weapon.mainhand diamond_sword
                    /replaceitem entity @s weapon.offhand shield
                    /replaceitem entity @s armor.head player_head{SkullOwner:"SethBling"}
                    /team join source
                end
                @s.to_display = create @CloneDisplay
                as @s.to_display
                    /replaceitem entity @s weapon.mainhand diamond_sword
                    /replaceitem entity @s weapon.offhand shield
                    /replaceitem entity @s armor.head player_head{SkullOwner:"SethBling"}
                    /team join dest
                end

				@s.clone_rotation = 0
				@s.clone_flip_x = False
				@s.clone_flip_z = False

                tell @s ''
                tell @s 'Move {BDest{w: {C[\[Up\]](/function blingedit:move_up) [\[Down\]](/function blingedit:move_down) [\[Left\]](/function blingedit:move_left) [\[Right\]](/function blingedit:move_right) [\[Forward\]](/function blingedit:move_forward) [\[Backward\]](/function blingedit:move_backward)'
                tell @s "Clone Options: {g[\[Do Clone Air\]](/function blingedit:clone_air) [\[Don't Clone Air\]](/function blingedit:dont_clone_air)"
				if @s.clone_in_place do tell @s "Clone In Place: {G[\[Enabled\]](/function blingedit:toggle_clone_in_place)"
				unless @s.clone_in_place do tell @s "Clone In Place: {R[\[Disabled\]](/function blingedit:toggle_clone_in_place)"
                tell @s 'Flip: {g[\[Flip Left/Right\]](/function blingedit:clone_flip_leftright) [\[Flip Front/Back\]](/function blingedit:clone_flip_frontback)'
                tell @s 'Rotate: {g[\[Rotate Left\]](/function blingedit:clone_rotate_left) [\[Rotate Right\]](/function blingedit:clone_rotate_right)'
                tell @s 'Actions: {G[\[Confirm Clone\]](/function blingedit:confirm_clone) [\[Clone&Repeat\]](/function blingedit:clone_and_repeat) [\[Clone Brush\]](/function blingedit:clone_brush) [\[Cancel\]](/function blingedit:cancel)'
            end
		else
			tell @s "You can't clone a box right now."
        end

        /gamerule sendCommandFeedback false
    end

    function confirm_clone()
        if @s.state == $EditDest
            @s.perform_clone()
            if loaded
                <move_by> = <dest_min> - <min>
                @s.cancel()
                as @Corner if @s.player == player and @s.type == $Type_Source
					if @s.edit_xmin then @s.x = dest_xmin
					if @s.edit_ymin then @s.y = dest_ymin
					if @s.edit_zmin then @s.z = dest_zmin
					if @s.edit_xmax then @s.x = dest_xmax
					if @s.edit_ymax then @s.y = dest_ymax
					if @s.edit_zmax then @s.z = dest_zmax
					if @s.center_x then @s.x = (dest_xmin + dest_xmax) / 2
					if @s.center_y then @s.y = (dest_ymin + dest_ymax) / 2
					if @s.center_z then @s.z = (dest_zmin + dest_zmax) / 2
                end
                @s.state = $EditSource
                @s.tell_actions()
            end
		else
			tell @s "You can't confirm a clone right now."
        end

        /gamerule sendCommandFeedback false
    end

    function clone_and_repeat()
        if @s.state == $EditDest
			okay_rotation = True
			if @s.clone_rotation == 90 then okay_rotation = False
			if @s.clone_rotation == 270 then okay_rotation = False

			if okay_rotation
				@s.perform_clone()
				if loaded
					<move_by> = <dest_min> - <min>
					as @Corner if @s.player == player
						@s.<pos> += <move_by>
					end
				end
			end
			unless okay_rotation
				tell @s '{GClone and Repeat{- is not implemented for perpendicular selections.'
			end
		else
			tell @s "You can't confirm a clone right now."
        end

        /gamerule sendCommandFeedback false
    end

    function clone_brush()
        can_do = False
        if @s.state == $EditDest then can_do = True
        if @s.state == $MovingDest then can_do = True

        if can_do
            @s.state = $CloneBrush
            @s.enable_click()
            as @Corner if @s.player == player if @s.type == $Type_Dest if @s.bottom_center
                moving = &@s
            end
            @s.moving = moving
            tell @s 'Clone Brush activated. Click to paste at destination.'
		else
			tell @s "You can't confirm a clone right now."
        end

        /gamerule sendCommandFeedback false
    end

    function perform_clone()
		unless @Position do create @Position
        /spreadplayers 0 0 1 1 false @Position

        /setblock 0 1 0 stone
        /execute store success score Global loaded run setblock 0 1 0 sandstone

        unless loaded
            tell @s "Chunk 0,0 wasn't loaded. Try again \(or use {C/forceload add 0 0{W\)"
        end
        if loaded
            @s.get_minmax()

            unless has_box
                tell @s "You don't currently have a region selected."
            end
            if has_box
                @s.get_dest_minmax()

                <size_x, size_y, size_z> = <size>
                clone_air = @s.clone_air

                if dest_xmin <= xmin
                    start_dx = 0
                    end_dx = size_x
                    step_dx = scale
                end
                if dest_xmin > xmin
                    start_dx = size_x
                    end_dx = 0
                    step_dx = -scale
                end
                if dest_ymin <= ymin
                    start_dy = 0
                    end_dy = size_y
                    step_dy = scale
                end
                if dest_ymin > ymin
                    start_dy = size_y
                    end_dy = 0
                    step_dy = -scale
                end
                if dest_zmin <= zmin
                    start_dz = 0
                    end_dz = size_z
                    step_dz = scale
                end
                if dest_zmin > zmin
                    start_dz = size_z
                    end_dz = 0
                    step_dz = -scale
                end

                /bossbar set progress players @s
                store_tile_drops()

				rotation = 0
				rotation = @s.clone_rotation
				flip_x = @s.clone_flip_x
				flip_z = @s.clone_flip_z

				dest_start_y = dest_ymin

				if rotation == 0
					dest_start_x = dest_xmin
					dest_start_z = dest_zmin
					flipped_x = dest_xmax
					flipped_z = dest_zmax
				end

				if rotation == 90
					dest_start_x = dest_xmax
					dest_start_z = dest_zmin
					flipped_x = dest_xmin
					flipped_z = dest_zmax
				end

				if rotation == 180
					dest_start_x = dest_xmax
					dest_start_z = dest_zmax
					flipped_x = dest_xmin
					flipped_z = dest_zmin
				end

				if rotation == 270
					dest_start_x = dest_xmin
					dest_start_z = dest_zmax
					flipped_x = dest_xmax
					flipped_z = dest_zmin
				end

				if flip_x then dest_start_x = flipped_x
				if flip_z then dest_start_z = flipped_z

				unless @Position do create @Position
				unless @Position2 do create @Position2
                as @Position
                    for dx = start_dx to end_dx by step_dx
                        percent = (dx - start_dx) / ((end_dx - start_dx) / 100)
                        /execute store result bossbar progress value run scoreboard players get Global percent
                        for dy = start_dy to end_dy by step_dy
                            for dz = start_dz to end_dz by step_dz
                                <offset> = <dx, dy, dz>
                                @s.<pos> = <min> + <offset>
                                at @s
									/clone ~ ~ ~ ~ ~ ~ 0 1 0
                                    skip = False
                                    if block ~ ~ ~ air unless clone_air
                                        skip = True
                                    end
                                end

                                unless skip
									if rotation == 0 then <dest_dx, dest_dy, dest_dz> = <dx, dy, dz>
									if rotation == 90 then <dest_dx, dest_dy, dest_dz> = <-dz, dy, dx>
									if rotation == 180 then <dest_dx, dest_dy, dest_dz> = <-dx, dy, -dz>
									if rotation == 270 then <dest_dx, dest_dy, dest_dz> = <dz, dy, -dx>
									if flip_x then dest_dx = dest_dx * -1
									if flip_z then dest_dz = dest_dz * -1

                                    @Position2.<pos> = <dest_start_x, dest_start_y, dest_start_z> + <dest_dx, dest_dy, dest_dz>
									at @Position2
										/clone 0 1 0 0 1 0 ~ ~ ~
                                    end
                                end
                            end
                        end
                    end
                end

                restore_tile_drops()
            end
        end
    end

    function cancel()
        handled = False
        can_cancel = False
        if @s.state == $EditDest then can_cancel = True
        if @s.state == $MovingDest then can_cancel = True
        if @s.state == $CloneBrush then can_cancel = True
        if can_cancel
            player = &@s
            as @Corner if @s.player == player and @s.type == $Type_Dest
                @s.player = None
            end
            @s.state = $EditSource
            @s.moving = None
            @s.tell_actions()
            handled = True
        end

        if not handled
            tell @s "You can't cancel right now."
        end

        /gamerule sendCommandFeedback false
    end

    function delete()
        @s.get_minmax()

        if has_box
            tell @s 'Deleting (box_xmin), (box_ymin), (box_zmin) to (box_xmax), (box_ymax), (box_zmax)'
            /bossbar set progress players @s
            store_tile_drops()
			unless @Position do create @Position
			for x = xmin to xmax by scale
				percent = (x - xmin) * 100 / (xmax - xmin)
				/execute store result bossbar progress value run scoreboard players get Global percent
				for z = zmin to zmax by scale
					for y = ymax to ymin by -scale
						@Position.<pos> = <x, y, z>
						at @Position
							/setblock ~ ~ ~ air
						end
					end
				end
			end
            restore_tile_drops()
        end

        unless has_box
            tell @s 'You must select a region first.'
        end

        /gamerule sendCommandFeedback false
    end

    function fill()
        tell @s 'Use {w[/setblock ~ ~ ~ <block>](//setblock ~ ~ ~ minecraft:){- to pick the filler block.'
        @s.state = $FillWait
        /gamerule sendCommandFeedback false
    end

    function replace()
        tell @s 'Use {w[/setblock ~ ~ ~ <block>](//setblock ~ ~ ~ minecraft:){- to pick the block to be replaced.'
        tell @s 'Or pick {C[\[air\]](/function blingedit:replace1_air){-'
        @s.state = $ReplaceWait1
        /gamerule sendCommandFeedback false
    end

    function replace1_air()
        /setblock ~ ~ ~ air
        @s.tell_replace2()
        /gamerule sendCommandFeedback false
    end

    function tell_replace2()
        check_loaded()

        if loaded
            /clone ~ ~ ~ ~ ~ ~ 0 2 0
            @s.state = $ReplaceWait2
            /setblock ~ ~ ~ air
            tell @s 'Use {w[/setblock ~ ~ ~ <block>](//setblock ~ ~ ~ minecraft:){- to pick the block they should be replaced with.'
            tell @s 'Or pick {C[\[air\]](/function blingedit:replace2_air){-'
        end
        unless loaded
            tell @s "Chunk 0,0 wasn't loaded. Try again \(or use {C/forceload add 0 0{W\)"
        end
    end

    function replace2_air()
        /setblock ~ ~ ~ air
        @s.perform_replace()
        /gamerule sendCommandFeedback false
    end

    function perform_replace()
        check_loaded()

        if loaded
            /clone ~ ~ ~ ~ ~ ~ 0 1 0

            @s.get_minmax()

            if has_box
                tell @s 'Replacing (box_xmin), (box_ymin), (box_zmin) to (box_xmax), (box_ymax), (box_zmax)'

                /bossbar set progress players @s
                store_tile_drops()
                count = 0
				unless @Position do create @Position
				for x = xmin to xmax by scale
					percent = (x - xmin) * 100 / (xmax - xmin)
					/execute store result bossbar progress value run scoreboard players get Global percent
					@Position.x = x
					for z = zmin to zmax by scale
						@Position.z = z
						for y = ymin to ymax by scale
							@Position.y = y
							at @Position
								replace = False
								/execute if blocks ~ ~ ~ ~ ~ ~ 0 2 0 all run scoreboard players set Global replace 1
								if replace
									count++
									/clone 0 1 0 0 1 0 ~ ~ ~
								end
							end
						end
					end
				end
                restore_tile_drops()

                tell @s 'Replaced (count) blocks.'
                @s.state = $EditSource
            end
            /setblock ~ ~ ~ air

            unless has_box
                tell @s 'You must select a box first.'
            end
        end
    end

    function move_up()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        as @Corner if @s.player == player and @s.type == type
            move @s ~ ~1 ~
        end
        /gamerule sendCommandFeedback false
    end
    function move_down()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        as @Corner if @s.player == player and @s.type == type
            move @s ~ ~-1 ~
        end
        /gamerule sendCommandFeedback false
    end

    function move_forward()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        ry = (@s.ry / scale) % 360

        move_dir()

        /gamerule sendCommandFeedback false
    end

    function move_backward()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        ry = (@s.ry / scale + 180) % 360

        move_dir()

        /gamerule sendCommandFeedback false
    end

    function move_left()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        ry = (@s.ry / scale - 90) % 360

        move_dir()

        /gamerule sendCommandFeedback false
    end

    function move_right()
        type = None
        if @s.state == $EditSource
            type = $Type_Source
        end
        if @s.state == $EditDest
            type = $Type_Dest
        end
        player = &@s
        ry = (@s.ry / scale + 90) % 360

        move_dir()

        /gamerule sendCommandFeedback false
    end

    function corner_target(type)
        player = &@s

        at @s ~ ~1.6 ~
			<start_pos> = here
			at ^ ^ ^1 do <look> = (here - <start_pos>)

			@Corner.looking = False

            as @Corner[distance=..30] if @s.player == player and @s.type == type
				@s.highlight = False
                <delta> = (@s.<pos> + <0, 500, 0> - <start_pos>)
				tca = (<delta> * <look>) / scale
				delta2 = <delta> * <delta> / scale
				tca2 = tca * tca / scale
				d2 = delta2 - tca2
				if d2 < 1700 and tca > 0 then @s.looking = True
            end

			as @Corner[sort=nearest,limit=1,looking]
				@s.highlight = True
			end

            as @Corner[distance=..30] if @s.player == player and @s.type == type
				if @s.highlight
                    /team join highlight
                    @s.highlighted = True
				else if type == $Type_Source
					/team join source
					@s.highlighted = False
				else if type == $Type_Dest
					/team join dest
					@s.highlighted = False
				end
            end
        end
    end

	function left_click_callback()
		@s.click()
	end

	function right_click_callback()
		@s.click()
	end

	function click()
		@Player.current = False
		@s.current = True
		@player = @Player[current,limit=1]

		move_dest = False
		if @s.state == $MovingDest then move_dest = True
		if @s.state == $CloneBrush then move_dest = True

		if @s.state == $EditSource
			as @Corner if @s.player == &@player and @s.type == $Type_Source and @s.highlighted
				/team join moving
				@player.moving = &@s
				@player.state = $EditingSource
			end
		else if @s.state == $EditingSource
			@s.get_cursor_position()
			unless @Position do create @Position
			@Position.<pos> = <cursor>
			at @Position
				as @s.moving
					/team join source
					@player.state = $EditSource
					@player.moving = None
					if @player.tell_actions
						<tx, ty, tz> = <x, y, z> / scale
						tell @player '2nd corner at {R(tx), (ty), (tz)'
						@player.tell_actions()
						@player.tell_actions = False
					end
				end
			end
		else if @s.state == $EditDest
			as @Corner if @s.player == &@player and @s.type == $Type_Dest and @s.highlighted
				/team join moving
				@player.moving = &@s
				@player.state = $MovingDest
			end
		else if move_dest
			if @s.state == $MovingDest
				as @s.moving
					/team join dest
				end
				@s.moving = None
				@s.state = $EditDest
			end
			if @s.state == $CloneBrush
				@s.perform_clone()
			end
		else if @s.state == $Pick1
			@s.get_cursor_position()
			unless @Position do create @Position
			@Position.<pos> = <cursor>
			at @Position
				as @s.pick1
					<x, y, z> = @s.<pos> / scale
					tell @player '1st corner at {R(x), (y), (z)'
				end
				@s.state = $EditingSource
				@s.tell_actions = True

				@s.pick2 = create @Corner
				as @s.pick2
					@s.player = &@player
					@s.type = $Type_Source
					/team join moving
					@s.edit_xmax = True
					@s.edit_ymax = True
					@s.edit_zmax = True
				end
				@s.moving = @player.pick2

				for ex = -1 to 1
					for ey = -1 to 1
						for ez = -1 to 1
							skip = False
							sum = abs(ex + ey + ez)

							skip = False
							if ex == -1 and ey == -1 and ez == -1 then skip = True
							if ex == 1 and ey == 1 and ez == 1 then skip = True
							if ex == 0 and ey == 0 and ez == 0 then skip = True

							if not skip
								as create @Corner
									@s.player = &@player
									@s.type = $Type_Source
									/team join source
									if ex == -1 then @s.edit_xmin = True
									if ex == 0 then @s.center_x = True
									if ex == 1 then @s.edit_xmax = True

									if ey == -1 then @s.edit_ymin = True
									if ey == 0 then @s.center_y = True
									if ey == 1 then @s.edit_ymax = True

									if ez == -1 then @s.edit_zmin = True
									if ez == 0 then @s.center_z = True
									if ez == 1 then @s.edit_zmax = True
								end
							end
						end
					end
				end

				move @Corner ~ ~ ~
			end
		end
	end
end

function move_dir()
    as @Corner if @s.player == player and @s.type == type
        if ry < 45
            move @s ~ ~ ~1
        end
        if ry > 45 and ry < 135
            move @s ~-1 ~ ~
        end
        if ry >= 135 and ry < 225
            move @s ~ ~ ~-1
        end
        if ry >= 225 and ry < 315
            move @s ~1 ~ ~
        end
        if ry >= 315
            move @s ~ ~ ~1
        end
    end
end

reset
	/gamerule maxCommandChainLength 1000000000

	/team add source
    /team modify source color red
    /team modify source collisionRule never

    /team add moving
    /team modify moving color yellow
    /team modify moving collisionRule never

    /team add highlight
    /team modify highlight color blue
    /team modify highlight collisionRule never

    /team add dest
    /team modify dest color green
    /team modify dest collisionRule never

    /execute store result score Global feedback run gamerule sendCommandFeedback
    /gamerule maxCommandChainLength 1000000000

    /bossbar add progress "Progress"
    /bossbar set progress max 100

	/scoreboard objectives remove used_carrot
	/scoreboard objectives add used_carrot minecraft.used:minecraft.carrot_on_a_stick

    /say Loaded BlingEdit v1.0.6 by SethBling
end

function check_loaded()
    /setblock 0 1 0 stone
    /execute store success score Global loaded run setblock 0 1 0 sandstone

    unless loaded
        tell @s "Chunk 0,0 wasn't loaded. Try again \(or use {C{U[/forceload add 0 0](//forceload add 0 0){u{W\)"
    end
end

function draw_particle_box()
	unless @Position do create @Position
    as @Position
        $particle = "fishing"
        for x = p_xmin to p_xmax by 200
            @s.<pos> = <x, p_ymin, p_zmin>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <x, p_ymin, p_zmax>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <x, p_ymax, p_zmin>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <x, p_ymax, p_zmax>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
        end
        for z = p_zmin to p_zmax by 200
            @s.<pos> = <p_xmin, p_ymin, z>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmax, p_ymin, z>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmin, p_ymax, z>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmax, p_ymax, z>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
        end
        for y = p_ymin to p_ymax by 200
            @s.<pos> = <p_xmin, y, p_zmin>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmin, y, p_zmax>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmax, y, p_zmin>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
            @s.<pos> = <p_xmax, y, p_zmax>
            at @s
                /particle $particle ~ ~ ~ 0 0 0 0 1 force
            end
        end
    end
end

function store_tile_drops()
    /execute store result score Global tile_drops run gamerule doTileDrops
    /gamerule doTileDrops false
end

function restore_tile_drops()
    if tile_drops
        /gamerule doTileDrops true
    end
    unless tile_drops
        /gamerule doTileDrops false
    end
end

clock main
    tick++

    if feedback
        /gamerule sendCommandFeedback true
    end

    as @Entity[type=item] at @s
        @s[nbt={Item:{tag:{display:{Name:"{\"text\":\"BlingEdit\"}"}}}}].edit = True
        if @s.edit
            found_player = False
            at @s as @Player[sort=nearest,limit=1,distance=..5]
                if @s.edit
                    @s.holding_item = True
					unless @s[nbt={SelectedItem:{}}] do @s.holding_item = False
                    unless @s.holding_item
                        if @s.carrot_on_stick
                            /replaceitem entity @s weapon.mainhand carrot_on_a_stick{display:{Name:"{\"text\":\"BlingEdit\"}"},Enchantments:[{lvl:5s,id:"minecraft:sharpness"}]} 1
                        end
                        unless @s.carrot_on_stick
                            /replaceitem entity @s weapon.mainhand diamond_sword{display:{Name:"{\"text\":\"BlingEdit\"}"}} 1
                        end
                        found_player = True

                        handled = False
                        if @s.raycast_select
                            @s.raycast_select = False
                            handled = True
                            tell @s 'Changed selection to: {YFloating Cursor'
                            tell @s 'Options: {y[\[Range 5\]](/function blingedit:cursor_range_5) [\[Range 10\]](/function blingedit:cursor_range_10) [\[Range 15\]](/function blingedit:cursor_range_15) [\[Range 20\]](/function blingedit:cursor_range_20)'
                        end
                        if not handled
                            @s.raycast_select = True
                            tell @s 'Changed selection to: {YRaycast Cursor'
                            tell @s 'Options: {y[\[Select Inside Blocks\]](/function blingedit:cursor_inside) [\[Select Before Blocks\]](/function blingedit:cursor_before)'
                        end
                    end
                end
            end
            /kill @s
        end
    end

    for @player in @Player
        at @s
			unless @s.cursor_range >= 0
                @s.cursor_range = 5
            end
            unless @s.cursor_inside >= 0
                @s.cursor_inside = True
            end

			if @s.used_carrot
				@s.click()
			end
			@s.used_carrot = 0

            # Make sure there's a value in edit
            unless @s.edit do @s.edit = False
            @s.prev_edit = @s.edit
            @s.edit = False
            @s[nbt={"SelectedItem":{tag:{display:{Name:"{\"text\":\"BlingEdit\"}"}}}}].edit = True
            @s.carrot_on_stick = False
            @s[nbt={"SelectedItem":{id:"minecraft:carrot_on_a_stick"}}].carrot_on_stick = True

			@s.disp_plugins = False

            if @s.prime_plugins
                @s.prime_plugins = False
                @s.disp_plugins = True
                tell @s '{cPlugins:'
            end

            if @s.edit unless @s.prev_edit
                @s.state = $Pick1
                at @s ~ ~200 ~
                    @s.pick1 = create @Corner
                    as @s.pick1
                        @s.player = &@player
                        /team join source
                        @s.type = $Type_Source
                        @s.edit_xmin = True
                        @s.edit_ymin = True
                        @s.edit_zmin = True
                    end
                end
				@s.enable_click()
            end

            if @s.prev_edit unless @s.edit
                @s.pick1 = None
                @s.pick2 = None
                @s.disable_click()
                @s.moving = None
                @s.state = $Closed
                as @Corner
					if @s.player == &@player
						@s.player = None
					end
                end
            end

            @s.get_minmax()
            if has_box and @s.particles
                @s.grid_display++
                if @s.grid_display >= 10
                    @s.grid_display = 0
                    <p_xmin, p_ymin, p_zmin> = <min> - <450, -175, 450>
                    <p_xmax, p_ymax, p_zmax> = <max> + <450, 1075, 450>

                    draw_particle_box()

                    @s.get_dest_minmax()
                    if has_dest_box
                        <p_xmin, p_ymin, p_zmin> = <dest_min> - <450, -175, 450>
                        <p_xmax, p_ymax, p_zmax> = <dest_max> + <450, 1075, 450>

                        draw_particle_box()
                    end
                end
            end

            if @s.state == $Pick1
                @s.get_cursor_position()
                corner_exists = False
                as @s.pick1
                    corner_exists = True
					unless @Position do create @Position
					@Position.<pos> = <cursor>
                    at @Position
                        /tp @s ~ ~ ~
                    end
                end

                if not corner_exists
                    tell @s "BlingEdit doesn't work in peaceful mode."
                    @s.state = $Closed
                end
            end

            @s.get_minmax()
            if has_box
                vol = box_size_x * box_size_y * box_size_z
                actionbar @s "Size: {y{D(box_size_x){-x{y{D(box_size_y){-x{y{D(box_size_z){- Volume: {y{D(vol){-"
            end

            @s.get_dest_minmax()
            if has_dest_box
                at @s ^7 ^6 ^10
                    as @s.from_display
                        /tp @s ~ ~ ~
                    end
                end
                at @s ^5 ^6 ^10
                    as @s.to_display
                        /tp @s ~ ~ ~
                    end
                end
            else
                @s.from_display = None
                @s.to_display = None
            end

            if @s.state == $EditingSource
                @s.get_cursor_position()
				unless @Position do create @Position
				@Position.<pos> = <cursor>
                at @Position
                    as @s.moving
                        /tp @s ~ ~ ~
                        <x, y, z> = @s.<pos>
                        <edit_xmin, edit_ymin, edit_zmin> = <False, False, False>
                        <edit_xmax, edit_ymax, edit_zmax> = <False, False, False>
                        if @s.edit_xmin then edit_xmin = True
                        if @s.edit_ymin then edit_ymin = True
                        if @s.edit_zmin then edit_zmin = True
                        if @s.edit_xmax then edit_xmax = True
                        if @s.edit_ymax then edit_ymax = True
                        if @s.edit_zmax then edit_zmax = True
                    end
                end
                as @Corner
                    if @s.player == &@player
                        if edit_xmin and @s.edit_xmin then @s.x = x
                        if edit_ymin and @s.edit_ymin then @s.y = y
                        if edit_zmin and @s.edit_zmin then @s.z = z
                        if edit_xmax and @s.edit_xmax then @s.x = x
                        if edit_ymax and @s.edit_ymax then @s.y = y
                        if edit_zmax and @s.edit_zmax then @s.z = z
                    end
                end
                @s.get_minmax()
                as @Corner
                    if @s.player == &@player
                        if @s.center_x then @s.x = (xmin + xmax) / 2
                        if @s.center_y then @s.y = (ymin + ymax) / 2
                        if @s.center_z then @s.z = (zmin + zmax) / 2
                    end
                end
            end

			if @s.state == $EditSource
				@s.corner_target($Type_Source)
			end


            if @s.state == $EditDest
                @s.corner_target($Type_Dest)
            end

            move_dest = False
            if @s.state == $MovingDest then move_dest = True
            if @s.state == $CloneBrush then move_dest = True

            if move_dest
                @s.get_cursor_position()
				unless @Position do create @Position
				@Position.<pos> = <cursor>
                at @Position
                    as @s.moving
                        <moving_pos> = @s.<pos>
                    end
                    <movement> = here - <moving_pos>
                    <movement> -= <movement> % 1000
                    as @Corner if @s.player == &@player and @s.type == $Type_Dest
                        @s.<pos> += <movement>
                    end
                end
            end

            if @s.state == $FillWait at @s unless block ~ ~ ~ air
				check_loaded()

				if loaded
					/clone ~ ~ ~ ~ ~ ~ 0 1 0
					@s.get_minmax()

					if has_box
						tell @s 'Filling (box_xmin), (box_ymin), (box_zmin) to (box_xmax), (box_ymax), (box_zmax)'

						/bossbar set progress players @s
						store_tile_drops()
						unless @Position do create @Position
						for x = xmin to xmax by scale
							percent = (x - xmin) * 100 / (xmax - xmin)
							/execute store result bossbar progress value run scoreboard players get Global percent
							for z = zmin to zmax by scale
								for y = ymin to ymax by scale
									@Position.<pos> = <x, y, z>
									at @Position
										/clone 0 1 0 0 1 0 ~ ~ ~
									end
								end
							end
						end
						restore_tile_drops()

						@s.state = $EditSource
					end
					/setblock ~ ~ ~ air

					unless has_box
						tell @s 'You must select a box first.'
					end
				end
            end

            if @s.state == $ReplaceWait1 at @s unless block ~ ~ ~ air
                @s.tell_replace2()
            end

            if @s.state == $ReplaceWait2 at @s unless block ~ ~ ~ air
                @s.perform_replace()
            end

            if @s.state == $ReplaceWaitRandom at @s unless block ~ ~ ~ air
				/clone ~ ~ ~ ~ ~ ~ 0 2 0
				/setblock ~ ~ ~ air

				@s.perform_random_replace()
            end
        end
    end
    collect_garbage()
end

function collect_garbage()
    /bossbar set progress players
    /execute store result bossbar progress value run scoreboard players set Global percent 0

    as @Corner
        @s.absorption = 100
        @s.<vel> = 0
        /effect give @s invisibility 1000000 0 true
        move @s ~ ~ ~
    end

    as @CloneDisplay
        @s.absorption = 100
        @s.fire = 0
        @s.<vel> = 0
        move @s ~ ~ ~
    end

    @Corner.kill = True
    @CloneDisplay.kill = True
    as @Player
		id = &@s
        at @s
            as @Corner if @s.player == id
                @s.kill = False
            end
            as @s.from_display
                @s.kill = False
            end
            as @s.to_display
                @s.kill = False
            end
        end
    end

    as @e[kill] at @s
        move @s ~ -100 ~
        /kill @s
    end
end
